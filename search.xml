<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>python</title>
      <link href="//post/python.html"/>
      <url>//post/python.html</url>
      
        <content type="html"><![CDATA[<h1 id="python-内置函数"><a href="#python-内置函数" class="headerlink" title="python 内置函数"></a>python 内置函数</h1><h2 id="Python-open"><a href="#Python-open" class="headerlink" title="Python open()"></a>Python open()</h2><p><code>open()</code>是处理文件的好方法。此方法将检查文件是否存在于指定的路径中，如果存在，它将返回文件对象，否则它将返回错误。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)</code></pre><p>本例中需要 8 个参数，其余都是可选的。在这种模式下类型有很多选项(r:读，w:写，x:独占创建，a:追加，t:文本模式，b:二进制模式，+:更新(读，写))</p><table><thead><tr><th>参数</th><th>描述</th><th>必需/可选</th></tr></thead><tbody><tr><td>文件file</td><td>类路径对象</td><td>需要</td></tr><tr><td>方式mode</td><td>模式(可选)-打开文件时的模式。如果未提供，则默认为“r”</td><td>可选择的</td></tr><tr><td>减轻buffering</td><td>用于设置缓冲策略</td><td>可选择的</td></tr><tr><td>编码encoding</td><td>编码格式</td><td>可选择的</td></tr><tr><td>错误errors</td><td>指定如何处理编码/解码错误的字符串</td><td>可选择的</td></tr><tr><td>新行newline</td><td>换行符模式如何工作(可用值:无’ ‘，’ \n ‘，’ r ‘和’ \r\n ‘)</td><td>可选择的</td></tr><tr><td></td><td></td><td></td></tr><tr><td>开启工具opener</td><td>定制的开瓶器；必须返回打开的文件描述符</td><td>可选择的</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>linux添加虚拟内存交换内存</title>
      <link href="//post/linux-swap.html"/>
      <url>//post/linux-swap.html</url>
      
        <content type="html"><![CDATA[<h2 id="linux添加虚拟内存交换内存"><a href="#linux添加虚拟内存交换内存" class="headerlink" title="linux添加虚拟内存交换内存"></a>linux添加虚拟内存交换内存</h2><p>当Linux内存不够的情况下，可以适当增加swap内存来分担</p><p>新建交换分区文件夹</p><pre class="line-numbers language-none"><code class="language-none">dd if=/dev/zero of=/tmp/swapfile bs=1024 count=1024k</code></pre><p><img src="https://oss.jayce.icu/markdown/image-20230515155918499.png" alt="image-20230515155918499"></p><p>格式化该分区为交换分区</p><pre class="line-numbers language-none"><code class="language-none">mkswap /tmp/swapfile</code></pre><p>开启该交换分区</p><pre class="line-numbers language-none"><code class="language-none">swapon /tmp/swapfile</code></pre><p>如果报错提示权限不足的话，还需添加权限    </p><p><code>swapon: /tmp/swapfile: insecure permissions 0644, 0600 suggested.</code></p><pre class="line-numbers language-none"><code class="language-none">chmod 600 /tmp/swapfile</code></pre><p> 接着启用sawp</p><pre class="line-numbers language-none"><code class="language-none">swapon /tmp/swapfile</code></pre><p>如果提示报错<code>swapon: /tmp/swapfile: swapon failed: Device or resource busy</code></p><p>先关闭在打开</p><pre class="line-numbers language-none"><code class="language-none">swapoff /tmp/swapfileswapon /tmp/swapfile</code></pre><p> 此时free查看swap内存已添加</p><p>设置</p><p><code>vim /etc/fstab</code></p><p>文件新加</p><pre class="line-numbers language-none"><code class="language-none">vm.swappiness=10      #当内存在使用到100-10=90%的时候，交换分区启动vm.vfs_cache_pressure=50  #虚拟内存回收directory和inode缓冲的倾向，这个值越大。越易回收</code></pre><p>重启生效</p>]]></content>
      
      
      <categories>
          
          <category> 问题解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ansible的部署配置与简单使用</title>
      <link href="//post/ansible-install.html"/>
      <url>//post/ansible-install.html</url>
      
        <content type="html"><![CDATA[<h1 id="ansible的部署配置与简单使用"><a href="#ansible的部署配置与简单使用" class="headerlink" title="ansible的部署配置与简单使用"></a>ansible的部署配置与简单使用</h1><h2 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h2><p>分别在centos的主机和docker中的centos部署ansible</p><h3 id="物理主机部署"><a href="#物理主机部署" class="headerlink" title="物理主机部署"></a>物理主机部署</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum -y install epel-releaseyum -y install ansible</code></pre><p>如果安装失败，尝试配置一下yum源</p><p>配置yum：</p><p>进入<code>/etc/yum.repos.d/</code>文件夹下创建一个阿里的镜像地址配置文件<code>aliBase.repo</code>,内容如下</p><pre class="line-numbers language-repo" data-language="repo"><code class="language-repo">[base]name=aliBasebaseurl=https://mirrors.aliyun.com/centos/$releasever/os/$basearch/gpgcheck=0[aliEpel]name=aliEpelbaseurl=https://mirrors.aliyun.com/epel/$releasever\Server/$basearch/gpgcheck=0[epel]name=epelbaseurl=https://mirrors.aliyun.com/epel-archive/7/x86_64/gpgcheck=0</code></pre><p>然后再执行<code>yum -y install ansible</code>即可</p><p>安装成功后执行<code>ansible --version</code>验证</p><p><img src="https://oss.jayce.icu/markdown/image-20230215161647664.png" alt="image-20230215161647664"></p><h2 id="机器配置与分组"><a href="#机器配置与分组" class="headerlink" title="机器配置与分组"></a>机器配置与分组</h2><p>主机的信息配置在<code>/etc/ansible/hosts</code> 文件中，想要批量操作主机，就需要提前对主机的连接参数进行配置，根据业务再把不同的主机分组，来执行各项命令</p><p>打开hosts文件已经有一些配置的样例在里面，如果想添加主机，需要先设置一个组，在这个组里填写每台主机的连接参数，实例如下：</p><pre class="line-numbers language-none"><code class="language-none">[webservers]192.168.42.131 ansible_ssh_port=22 ansible_ssh_user=root ansible_ssh_pass="12345"192.168.42.132 ansible_ssh_port=22 ansible_ssh_user=root ansible_ssh_pass="12345"</code></pre><p>该配置将两台主机分到webservers这一组下，配置了ip，ssh端口，用户名及密码，此时保存退出，使用ansible webservers -m ping 来试一下连通性</p><p>如果网络正常的话，可能会出现下面的报错</p><p><img src="https://oss.jayce.icu/markdown/image-20230215162530953.png" alt="image-20230215162530953"></p><p>原因是该主机没有连接过配置中的主机，导致宿主机的known_hosts中没有相关记录，简单的方法是直接使用ssh命令连一下</p><p><img src="https://oss.jayce.icu/markdown/image-20230215162756540.png" alt="image-20230215162756540"></p><p>输入yes后即可更新known_hosts</p><p>如果不想每台主机都ssh连一下，可以修改配置文件关闭验证</p><p>在<code>/etc/ansible/ansible.cfg</code> 文件下将<code>host_key_checking = False</code> 前的注释去掉</p><p>测试成功的输出如下</p><p><img src="https://oss.jayce.icu/markdown/image-20230215163151910.png" alt="image-20230215163151910"></p><p>除了最简单的ip加用户名密码这种最简单的方式外，多个ip还支持合并，比如</p><p><code>192.168.42.13[1:3]</code> 代表<code>192.168.42.131</code> <code>192.168.42.132</code> <code>192.168.42.133</code> 这三个ip</p><p>端口也可以直接跟在ip后面</p><pre class="line-numbers language-none"><code class="language-none">192.168.42.131:22 ansible_ssh_user=root ansible_ssh_pass="12345"192.168.42.13[1:3]:22 ansible_ssh_user=root ansible_ssh_pass="12345"</code></pre><h2 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h2>]]></content>
      
      
      <categories>
          
          <category> 部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> 服务器 </tag>
            
            <tag> 部署 </tag>
            
            <tag> linux </tag>
            
            <tag> ansible </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows环境使用vscode在linux环境编写shell和python脚本</title>
      <link href="//post/vscode-wsl.html"/>
      <url>//post/vscode-wsl.html</url>
      
        <content type="html"><![CDATA[<h1 id="使用vscode在linux环境编写shell和python脚本"><a href="#使用vscode在linux环境编写shell和python脚本" class="headerlink" title="使用vscode在linux环境编写shell和python脚本"></a>使用vscode在linux环境编写shell和python脚本</h1><p>对于经常编写脚本的人来说，编写shell一般都会在vim或记事本中，这样的方式没什么问题，但遇到需要测试的时候，就没有IDE那样的方便，而且使用IDE对shell的自动补全会让效率翻倍。<br>此文章将讲述如何在windows vscode中配置Linux运行环境，让你run code即可看到输出。</p><h2 id="安装vscode"><a href="#安装vscode" class="headerlink" title="安装vscode"></a>安装vscode</h2><p>安装vscode的方式在这就不做大篇的叙述了，百度vscode，下载安装包，点击下一步安装即可<br><a href="https://code.visualstudio.com/">下载地址点我</a>    </p><h2 id="安装WSL"><a href="#安装WSL" class="headerlink" title="安装WSL"></a>安装WSL</h2><p>简单讲下WSL，这里我们将使用WSL作为脚本的运行环境<br>WSL是一个在Windows 10\11上能够运行原生Linux二进制可执行文件的兼容层。注意它并不是虚拟机。<br>步骤<br>右键单击windows徽标，打开Powershell（管理员），执行</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux</code></pre><p>即可将WSL功能激活。</p><p>接着在微软商店中挑一个你想用的Linux发行版</p><p><img src="https://oss.jayce.icu/markdown/image-20221128152641580.png" alt="image-20221128152641580"></p><p>这里我选择了Ubuntu 20，直接点击安装即可。安装成功后，在开始菜单中点击运行，看看是否正常，一般第一次都需要设置用户和密码</p><p><img src="https://oss.jayce.icu/markdown/image-20221128152909237.png" alt="image-20221128152909237"></p><p>这就是wsl Ubuntu的界面，当你正常设置好用户名和密码，出现这个界面后，说明你的WSL安装正常了<img src="https://oss.jayce.icu/markdown/image-20221128152945459.png" alt="image-20221128152945459"></p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>想必大家肯定不是第一次使用vscode的人了，就直接开门见山，直说需要安装什么插件好了</p><ul><li>Code Runner</li><li>WSL</li><li>Remote - SSH</li><li>ShellCheck</li><li>Shellman</li><li>Shell-format</li></ul><p>更多好用的脚本可自行安装</p><p>这里核心的插件是WSL，这里的wsl只是一个插件，和刚才安装的不一样，这个是用来连接WSL的</p><p>此时，在新建终端时，就可以看到刚才安装的WSL，这里我把它设置成了默认</p><p><img src="https://oss.jayce.icu/markdown/image-20221128154132874.png" alt="image-20221128154132874"></p><p>新建一个终端看看是不是WSL</p><p><img src="https://oss.jayce.icu/markdown/image-20221128154228391.png" alt="image-20221128154228391"></p><p>此时就可以在这里的终端直接输入各类命令使用了，目录也是windows下的目录，比如上图中当前的目录为<code>/mnt/e</code>，就代表现在在windows 中的E盘，这里需要注意的是，访问windows的文件管理器时，都要在mnt目录下寻找，WSL将windows 下的各个盘挂载在mnt下，当然你也可以使用WSL环境的linux目录结构。</p><p>vscode中setting.json部分配置如下</p><p><img src="https://oss.jayce.icu/markdown/image-20221128161645440.png" alt="image-20221128161645440"></p><h2 id="Code-Runner插件配置"><a href="#Code-Runner插件配置" class="headerlink" title="Code Runner插件配置"></a>Code Runner插件配置</h2><p>在vscode安装好linux环境后还不能优雅的调试写好的脚本，我们希望在点击run code按钮后，终端直接执行脚本，但现在还无法做到，现在执行脚本会有如下报错：</p><p><img src="https://oss.jayce.icu/markdown/image-20221128155757738.png" alt="image-20221128155757738"></p><p>这是因为code runner 在执行shell时不能识别WSL，这时我们就要对code runner做一些修改。</p><p>找到code runner的安装目录，插件一般放在<code>C:\Users\用户名\.vscode\extensions</code></p><p>code runner的文件名是formulahendry.code-runner，进入out\src 下，找到codeManager.js，在编辑器中打开。</p><p>找到</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">else if (windowsShell &amp;&amp; windowsShell.toLowerCase().indexOf("bash") &gt; -1 &amp;&amp; windowsShell.toLowerCase().indexOf("windows") &gt; -1) {    command = command.replace(/([A-Za-z]):\\/g, this.replacer).replace(/\\/g, "/");}</code></pre><p>这段代码需改改成</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">else if (windowsShell &amp;&amp; windowsShell.toLowerCase().indexOf("wsl") &gt; -1) {command = command.replace(/([A-Za-z]):/g, this.replacer).replace(/\\/g, "/");}</code></pre><p>保存重启vscode即可</p><p>此时我们再运行code runner，即可正常在WSL里执行脚本了</p><p><img src="https://oss.jayce.icu/markdown/image-20221128161103550.png" alt="image-20221128161103550"></p><h2 id="Python脚本"><a href="#Python脚本" class="headerlink" title="Python脚本"></a>Python脚本</h2><p>只需要在WSL中安装python即可</p><p><img src="https://oss.jayce.icu/markdown/image-20221128161529394.png" alt="image-20221128161529394"></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> python </tag>
            
            <tag> shell </tag>
            
            <tag> WSL </tag>
            
            <tag> vscode </tag>
            
            <tag> 脚本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SHELL学习笔记</title>
      <link href="//post/shell.html"/>
      <url>//post/shell.html</url>
      
        <content type="html"><![CDATA[<h1 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h1><p>学习脚本编程</p><h2 id="shell用途"><a href="#shell用途" class="headerlink" title="shell用途"></a>shell用途</h2><p>实现自动化</p><ol><li>自动化批量初始化(update，软件安装)</li><li>自动化软件部署（tomcat，nginx）</li><li>管理应用程序（KVM，集群管理扩容，Mysql）</li><li>日志分析处理程序（PV，UV，200，!200,grep/awk,top 100）</li><li>自动化备份，恢复程序（Mysql完全备份/增量 + crond）</li><li>自动化管理程序（批量修改，升级，配置更新）</li><li>自动化信息采集，监控（收集系统/应用状态信息，CPU，内存，disk，apache，Mysql，tcp状态）Zabbix专业软件可实现采集</li><li>自动化扩容（增加云主机–&gt;部署应用）通过监控</li></ol><h2 id="shell-打印"><a href="#shell-打印" class="headerlink" title="shell 打印"></a>shell 打印</h2><h3 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h3><p><strong>echo是用于终端打印的基本命令</strong></p><p>echo每次调用都会自动换行</p><p>输出的方式三种，无引号，双引号（需要转义），单引号（原样输出）</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>使用双引号打印遇到特殊字符就需要转义，或者不要使用双引号，换成单引号可原样输出</p><p>如果不使用引号，则没法再文本中显示<code>;</code>，因为分号在bash中为命令界定</p><p>单引号的缺点是不能变量替换</p><h3 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h3><p><strong>printf也是用于终端打印的基本命令：</strong></p><p>printf使用引用文本或由空格分隔的参数。</p><p><strong>％ns</strong> 输出一个字符串，n是数字代指输出几个字符</p><p><strong>%ni</strong>： 输出整数</p><p><strong>％d</strong> 整型输出，</p><p><strong>％c</strong> 输出一个字符，</p><p><strong>％f</strong> 输出实数，以小数形式输出。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">printf "%-10s %-8s %-4s\n" 姓名 性别 体重kg  printf "%-10s %-8s %-4.2f\n" 郭靖 男 66.1234printf "%-10s %-8s %-4.2f\n" 杨过 男 48.6543printf "%-10s %-8s %-4.2f\n" 郭芙 女 47.9876</code></pre><p><strong>%-10s</strong> 指一个宽度为 10 个字符（**-** 表示左对齐，没有则表示右对齐）</p><p><strong>%-4.2f</strong> 指格式化为小数，其中 <strong>.2</strong> 指保留2位小数。</p><p>输出格式:</p><table><thead><tr><th>格式</th><th>功能</th></tr></thead><tbody><tr><td>\a</td><td>输出警告声音</td></tr><tr><td>\b</td><td>输入退格键</td></tr><tr><td>\f</td><td>清楚屏幕</td></tr><tr><td>\n</td><td>换行</td></tr><tr><td>\r</td><td>回车</td></tr><tr><td>\t</td><td>水平输出退格</td></tr><tr><td>\v</td><td>垂直输出退格</td></tr></tbody></table><h2 id="文件描述符与重定向"><a href="#文件描述符与重定向" class="headerlink" title="文件描述符与重定向"></a>文件描述符与重定向</h2><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>文件描述符是与输入和输出流相关联的整数。常用的文件描述符是stdin、stdout和stderr</p><ul><li>0 —— stdin（标准输入）</li><li>1 —— stdout（标准输出）</li><li>2 —— stderr（标准错误）</li></ul><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>Linux Shell 重定向分为两种，一种输入重定向，一种是输出重定向；</p><ul><li><p>输入方向就是数据从哪里流向程序。数据默认从键盘流向程序，如果改变了它的方向，数据就从其它地方流入，这就是输入重定向。</p></li><li><p>输出方向就是数据从程序流向哪里。数据默认从程序流向显示器，如果改变了它的方向，数据就流向其它地方，这就是输出重定向。</p></li></ul><table><caption>表2：Bash 支持的输出重定向符号</caption><tbody><tr></tr><tr><th>类&nbsp;型</th><th>符&nbsp;号</th><th>作&nbsp;用</th></tr><tr><td rowspan="2">标准输出重定向</td><td>cmd&nbsp;&gt;file</td><td>以覆盖的方式，把 cmd 的正确输出结果输出到 file&nbsp;文件中。</td></tr><tr><td>cmd &gt;&gt;file</td><td>以追加的方式，把 cmd 的正确输出结果输出到 file&nbsp;文件中。</td></tr><tr><td rowspan="2">标准错误输出重定向</td><td>cmd 2&gt;file</td><td>以覆盖的方式，把 cmd 的错误信息输出到 file&nbsp;文件中。</td></tr><tr><td>cmd 2&gt;&gt;file</td><td>以追加的方式，把 cmd&nbsp;的错误信息输出到 file&nbsp;文件中。</td></tr><tr><td colspan="1" rowspan="6">正确输出和错误信息同时保存</td><td>cmd &gt;file&nbsp;2&gt;&amp;1</td><td>以覆盖的方式，把正确输出和错误信息同时保存到同一个文件（file）中。</td></tr><tr><td>cmd &gt;&gt;file&nbsp;2&gt;&amp;1</td><td>以追加的方式，把正确输出和错误信息同时保存到同一个文件（file）中。</td></tr><tr><td>cmd &gt;file1 2&gt;file2</td><td>以覆盖的方式，把正确的输出结果输出到 file1 文件中，把错误信息输出到 file2 文件中。</td></tr><tr><td>cmd &gt;&gt;file1&nbsp; 2&gt;&gt;file2</td><td>以追加的方式，把正确的输出结果输出到 file1 文件中，把错误信息输出到 file2 文件中。</td></tr><tr><td>cmd &gt;file 2&gt;file</td><td colspan="1" rowspan="2">【<span><b>不推荐</b></span>】这两种写法会导致 file 被打开两次，引起资源竞争，所以 stdout 和 stderr 会互相覆盖</td></tr><tr><td>cmd &gt;&gt;file 2&gt;&gt;file</td></tr></tbody></table><p>例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#标准输出echo ‘helllo world’ &gt; hello.txtecho ‘helllo world’ &gt;&gt; hello.txt   #结果#‘helllo world’#‘helllo world’</code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#标准错误输出重定向cd sh 2&gt; error.logcd shell 2&gt;&gt; error.log   #结果#-bash: cd: sh: No such file or directory#-bash: cd: shell: No such file or directory</code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#正确输出和错误信息同时保存#同一文件cat 1.txt &gt; out.log 2&gt;&amp;1    #结果#cat: 1.txt: No such file or directory#hello#不同文件cat 1.txt &gt; out.log 2&gt;error.log</code></pre><p>如果既想把<code>stdout</code>打印出终端，又想重定向至文件，就需要用到<code>tee</code>命令</p><h4 id="tee命令"><a href="#tee命令" class="headerlink" title="tee命令"></a><code>tee</code>命令</h4><p> tee命令用于读取标准输入的数据，并将其内容输出成文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat a* |tee  error.log </code></pre><p><img src="C:\Users\MyPC\OneDrive\shell\shell.assets\202202140219700.png" alt="image-20220214021923090"></p><p>注意：tee只能读取stdin ，不能读取到stderr</p><p>默认情况tee为覆盖文件，等同于<code>&gt;</code> ，加入<code>-a</code> 参数为追加内容，类似于<code>&gt;&gt;</code></p><h2 id="shell变量"><a href="#shell变量" class="headerlink" title="shell变量"></a>shell变量</h2><h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><p>定义变量时，变量名和等号之间不能有空格</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">filename="jayce.txt"</code></pre><h3 id="定义命令"><a href="#定义命令" class="headerlink" title="定义命令"></a>定义命令</h3><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">variable=`command`variable=$(command)</code></pre><h3 id="定义规则"><a href="#定义规则" class="headerlink" title="定义规则"></a><strong>定义规则</strong></h3><ol><li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头</li><li>中间不能有空格，可以使用下划线 <code>_</code></li><li>不能使用标点符号</li><li>不能使用bash里的关键字</li></ol><h3 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h3><p>在变量名前加<code>$</code></p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">name="Jayce"echo $nameecho ${name}</code></pre><p>注意：花括号可选，但最好加</p><h3 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h3><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">name="Jayce"readonly name</code></pre><p>添加了只读后，变量就不可以在变更值</p><h3 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h3><p><code>unset</code> unset可以删除变量</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">unset name</code></pre><p><strong>注意：unset不能删除只读变量</strong></p><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><p>与其他编程语言类似，shell有三种变量类型</p><ol><li><strong>局部变量</strong> 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。</li><li><strong>环境变量</strong> 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。</li><li><strong>shell变量</strong> shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行</li></ol><h3 id="shell字符串"><a href="#shell字符串" class="headerlink" title="shell字符串"></a>shell字符串</h3><p>在定义字符串的时候，有三种方法</p><ul><li>单引号<ul><li>单引号中任何字符都可以原样输出，不可嵌套变量</li><li>单引号中不可单独出现单独的单引号，转义也不行，但成对可以</li></ul></li><li>双引号<ul><li>双引号可以有变量</li><li>双引号可出现转义字符</li></ul></li><li>不用引号</li></ul><h4 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h4><ul><li>双引号</li></ul><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">your_name="Jayce"greeting="hello, "$your_name" !"greeting_1="hello, ${your_name} !"echo $greeting  $greeting_1#输出 hello, Jayce ! hello, Jayce !</code></pre><ul><li>单引号</li></ul><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">greeting_2='hello, '$your_name' !'greeting_3='hello, ${your_name} !'echo $greeting_2  $greeting_3#输出 hello, Jayce ! hello, ${your_name} !</code></pre><p>其中greeting_2中的变量其实并没有在单引号内</p><p>greeting_3中的变量未生效，被当做了字符串</p><h4 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h4><p>`$</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> mysql </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LINUX学习笔记</title>
      <link href="//post/linux.html"/>
      <url>//post/linux.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p><strong>不要再服务器访问高峰运行高负载命令</strong></p><p><strong>远程配置防火墙时不要把自己踢出防火墙</strong></p><p><strong>合理分配权限</strong></p><p><strong>定时备份数据和日志</strong></p><hr><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>软连接：类似于快捷方式  </p><p>硬链接：类似于拷贝，相比于cp -p  两个文件可以同时更新</p><p>删除源文件后，软连接不可访问，硬链接可以继续访问</p><p>硬链接不可以操作目录</p><p>如何判断是否是硬链接：</p><p>​    查看i节点，一个i节点会映射到多个文件 </p><hr><h3 id="目录作用"><a href="#目录作用" class="headerlink" title="目录作用"></a>目录作用</h3><table><thead><tr><th>目录名</th><th>作用</th></tr></thead><tbody><tr><td>/bin</td><td>存放系统命令</td></tr><tr><td>/sbin</td><td>保存和系统环境设置相关的命令</td></tr><tr><td>/usr/bin</td><td>存放系统命令，区别是单用户模式下不能执行</td></tr><tr><td>/usr/sbin</td><td>存放根文件系统不必要的系统管理命令</td></tr><tr><td>/boot</td><td>系统启动目录</td></tr><tr><td>/dev</td><td>设备文件</td></tr><tr><td>/etc</td><td>配置文件</td></tr><tr><td>/home</td><td>家目录</td></tr><tr><td>/lib</td><td>系统调用函数库保存位置</td></tr><tr><td>/lost+found</td><td>根分区备份恢复目录</td></tr><tr><td>/media</td><td>挂载目录，系统建议只挂载媒体设备</td></tr><tr><td>/mnt</td><td>挂载目录，硬盘，U盘</td></tr><tr><td>/misc</td><td>挂载目录，建议挂载NFS服务</td></tr><tr><td>/opt</td><td>第三方安装软件保存位置</td></tr><tr><td>/prco</td><td>虚拟文件系统，数据不会存在硬盘中</td></tr><tr><td>/sys</td><td>和prco相似，主要保存内核信息</td></tr><tr><td>/root</td><td></td></tr><tr><td>/srv</td><td>服务数据目录</td></tr><tr><td>/tmp</td><td>临时目录，存放临时文件</td></tr><tr><td>/usr</td><td>系统软件资源目录</td></tr><tr><td>/var</td><td>动态数据保存位置</td></tr></tbody></table><p>挂载目录类似于Windows的盘符</p><h3 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h3><h4 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h4><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">scp [-1246BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file][-l limit] [-o ssh_option] [-P port] [-S program][[user@]host1:]file1 [...] [[user@]host2:]file2</code></pre><p>简易</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">scp file root@ip:folder #或者 scp file root@ip:file #或者 scp file ip:folder #或者 scp file ip:file </code></pre><p>指定了远程的目录，文件名字不变，指定文件名，则传输后重命名</p><p>传输文件夹使用 -r 参数，文件夹会传输到指定的目录下，而不是重命名</p><p>例如</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">scp -r /root/shell 172.0.0.1:/root/linux/ </code></pre><p>将本地 shell目录复制到远程 linux目录下 <code>/root/linux/shell</code></p><p>相关参数：</p><p><code>-P</code>   指定端口号</p><p><code>-i</code>  使用密钥文件登录</p><pre class="line-numbers language-none"><code class="language-none">scp  -i key.pem  /root/file  ip:dic </code></pre><hr><h2 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h2><ol><li><p>物理终端</p><p>直接接入本机</p></li><li><p>虚拟终端</p><p>在物理终端商软件虚拟实现的终端，centos6 有默认6个虚拟终端</p><p>Ctrl + Alt + Fn （n = 1-6）</p><p>设备文件路径：/dev/tty#</p></li><li><p>模拟终端</p><p>图形界面打开的命令行、ssh、telnet</p><p>设备文件路径：/dev/pts/# 无穷个</p></li></ol><p>查看终端设备<code>tty</code></p><hr><h2 id="命令提示符"><a href="#命令提示符" class="headerlink" title="命令提示符"></a>命令提示符</h2><pre class="line-numbers language-none"><code class="language-none">prompt</code></pre><p>[root@localhost ~]#</p><p> [root@localhost ~] : PS1</p><p> prompt:</p><p> 管理员：#</p><p> 普通用户：$</p><hr><h2 id="系统分区"><a href="#系统分区" class="headerlink" title="系统分区"></a>系统分区</h2><h3 id="主分区"><a href="#主分区" class="headerlink" title="主分区"></a>主分区</h3><p>最多只能有4个</p><h3 id="扩展分区"><a href="#扩展分区" class="headerlink" title="扩展分区"></a>扩展分区</h3><p>当主分区不够时，拿出一个分区做扩展分区</p><p>扩展分区最多只能有1个</p><p>主分区加扩展分区最多有4个</p><p>不能写入数据，不能格式化，只能包含逻辑分区</p><h3 id="逻辑分区"><a href="#逻辑分区" class="headerlink" title="逻辑分区"></a>逻辑分区</h3><p>可以写入数据，</p><h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><p>高级格式化，又称逻辑格式化，它指根据用户选定的文件系统（FAT32，NTFS，EXT2，3，4）</p><p>linux默认EXT4格式会把分区变成一个一个等大小的数据块，每个数据块为4kb</p><p>文件有一个inode号，文件读取通过这个编号去硬盘分区数据块后找</p><hr><h2 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h2><hr><h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p>文件权限：r读，w写，x执行</p><p>rw- r– r–</p><p>u    g   o  </p><p>u所有者 g所属组 o 其他人</p><p>权限够用就行，除了可执行文件（脚本等），不需要执行权限</p><table><thead><tr><th>字符</th><th>权限</th><th>对文件含义</th><th>对目录含义</th><th>文件操作</th><th>目录操作</th></tr></thead><tbody><tr><td>r</td><td>读</td><td>查看文件内容</td><td>列出目录内容</td><td>cat、tail、less..</td><td>ls</td></tr><tr><td>w</td><td>写</td><td>修改文件</td><td>目录中创建、删除文件</td><td>vim</td><td>touch 、mkdir、rm</td></tr><tr><td>x</td><td>执行</td><td>进入目录，执行文件</td><td>进入目录</td><td>bash等</td><td>cd</td></tr></tbody></table><p>对文件的删除权限其实要看所属目录的权限是否有写权限</p><hr><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>输入命令，回车:</p><p> shell程序找到键入命令所对应的可执行程序或代码，并由其分析后提交给内核分配资源将其运行起来。表现为一个或多个进程。</p><p>在shell中可执行的命令有两类:</p><p> 内建命令:由shell自带的，而且通过某命令形式提供;</p><p> 外部命令:在当前系统的某文件系统路径下有对应的可执行程序文件:</p><p> which, whereis</p><p>区别内部或外部命令:</p><p> <code>type COMMAND</code></p><p>shell 程序可搜寻的执行文件的路径定义在PATH环境变量中：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">ehco $PATH</code></pre><p><a href="https://camo.githubusercontent.com/72c3852f5994102902bc5cb38228ed4e502a885f25393052592d5dccf242b8de/68747470733a2f2f6a6179636568652e6f73732d636e2d68616e677a686f752e616c6979756e63732e636f6d2f696d6167652d32303231313230343233333535373937332e706e67"><img src="https://oss.jayce.icu/markdown/202201062321146.png" alt="image-20211204233557973"></a></p><p>自左至右依次查询，查到停止</p><p>shell搜寻代外部命令的路径结果会缓存至kv（key-value）存储中：</p><p>可用命令<code>hash</code>命令查看</p><p><a href="https://camo.githubusercontent.com/d8a9732dce4431d1d85d8d7a018a54a899b541cbc78c7d0041ca23e07609f8ba/68747470733a2f2f6a6179636568652e6f73732d636e2d68616e677a686f752e616c6979756e63732e636f6d2f696d6167652d32303231313230343233343235393435322e706e67"><img src="https://oss.jayce.icu/markdown/202201062322340.png" alt="image-20211204234259452"></a></p><p><strong>缓存副作用：</strong></p><p>如果命令位置发生了转移，系统还是会按缓存路径运行，导致命令失效</p><pre class="line-numbers language-none"><code class="language-none">mv /bin/ls /usr/bin/lsls# -bash: /bin/ls: NO such file or directory</code></pre><p>清除缓存：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">hash -d [command] #删除一个命令缓存hash -r  #删除所有缓存</code></pre><hr><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><h3 id="linux-amp-macos"><a href="#linux-amp-macos" class="headerlink" title="linux&amp;macos"></a>linux&amp;macos</h3><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">ssh username@ip </code></pre><p>-p：指定端口</p><p>使用私钥登陆：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">ssh -i ~/.ssh/jayce username@ip</code></pre><p>文件</p><hr><h2 id="关机与重启"><a href="#关机与重启" class="headerlink" title="关机与重启"></a>关机与重启</h2><h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a><code>shutdown</code></h3><p>立即关机：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">shutdown -h now</code></pre><p>延迟一分钟关机</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">shutdown -h 1</code></pre><h3 id="halt"><a href="#halt" class="headerlink" title="halt"></a><code>halt</code></h3><p>直接关机</p><h3 id="reboot"><a href="#reboot" class="headerlink" title="reboot"></a><code>reboot</code></h3><p>重启系统</p><h3 id="sync"><a href="#sync" class="headerlink" title="sync"></a><code>sync</code></h3><p>将内存的数据同步到磁盘</p><p>作用：关机和重启之前执行。放止数据丢失</p><hr><h2 id="登陆和注销"><a href="#登陆和注销" class="headerlink" title="登陆和注销"></a>登陆和注销</h2><p>登陆少用root账号登陆，可避免操作失误。</p><p>可使用普通用户登陆，再用<code>su -用户名</code>切换系统管理员身份</p><h3 id="logout"><a href="#logout" class="headerlink" title="logout"></a><code>logout</code></h3><p>注销</p><p>logout在图形运行级别无效，在运行级别3下有效</p><hr><h2 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a>运行级别</h2><p>linux有7个运行级别</p><p>0：关机</p><p>1：单用户（可找回密码，不需要密码）</p><p>2：多用户无网络</p><p>3：多用户有网络</p><p>4：保留</p><p>5：图形界面</p><p>6：重启</p><p>常用的是3和5</p><p>运行级别配置文件：/etc/inittab (centos7以前)</p><p>在配置文件中修改运行级别</p><hr><h3 id="切换指定运行级别"><a href="#切换指定运行级别" class="headerlink" title="切换指定运行级别"></a>切换指定运行级别</h3><p>基本语法</p><p>init [012356]</p><hr><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><h3 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h3><p>系统可以对有共性的多个用户进行统一的管理</p><p>每个用户至少属于一个组</p><p>比如root属于root组</p><h3 id="增加删除组"><a href="#增加删除组" class="headerlink" title="增加删除组"></a>增加删除组</h3><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">groupaddgroupdel</code></pre><h3 id="家目录"><a href="#家目录" class="headerlink" title="家目录"></a>家目录</h3><p>home目录下有各个用户的家目录</p><p>当用户登陆时，会自动进入自己的家目录</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">/home/jayce</code></pre><h3 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h3><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">useradduseradd -d /home/jayce -m jayce</code></pre><p>-d ： 指定用户目录</p><p>-m ： 如果目录为空，则新建</p><p>-g：指定用户组</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">passwd</code></pre><p>设置密码</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">passwd jayce</code></pre><p>在创建好用户后要设置密码</p><h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">userdel</code></pre><p>默认加用户名是不会删除其所有文件的</p><p>-f ：强制删除，即时已经登陆</p><p>-r：连同相关用户文件一起删除</p><p><strong>另一种方法：</strong></p><p>进入<code>/etc/passwd</code>中，删除用户记录</p><p>⚠️不安全</p><h3 id="修改用户的组"><a href="#修改用户的组" class="headerlink" title="修改用户的组"></a>修改用户的组</h3><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">usermodusermod -g usergroup username</code></pre><h3 id="查看用户"><a href="#查看用户" class="headerlink" title="查看用户"></a>查看用户</h3><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">id username</code></pre><h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">su - username</code></pre><p>从高权限到低权限不需要密码</p><p>返回root用<code>exit</code></p><h4 id="查看当前用户"><a href="#查看当前用户" class="headerlink" title="查看当前用户"></a>查看当前用户</h4><p><code>who am i</code> = <code>whoami</code></p><h3 id="用户信息存放"><a href="#用户信息存放" class="headerlink" title="用户信息存放"></a>用户信息存放</h3><ul><li><h2 id="用户配置文件：-etc-passwd"><a href="#用户配置文件：-etc-passwd" class="headerlink" title="用户配置文件：/etc/passwd"></a>用户配置文件：/etc/passwd</h2><ul><li>用户名:密码(加密在shadow):用户id:组id::家目录:对应的shell</li></ul></li><li>组配置文件：/etc/group<ul><li>组名:口令:组id:列表(看不到)</li></ul></li><li>口令配置文件：/etc/shadow<ul><li>加密文件存放密码</li></ul></li></ul><h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><h3 id="man"><a href="#man" class="headerlink" title="man"></a><code>man</code></h3><p> 查看指令手册</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">/usr/share/man</code></pre><p>man1—man9</p><p>有多个man的目的是为了区分权限</p><p> <code>man1</code> 用户命令</p><p> <code>man2</code> 系统调用</p><p> <code>man3</code> c库调用</p><p> <code>man4</code> 设备及特殊文件</p><p> <code>man5</code> 配置文件格式</p><p> <code>man6</code> 游戏</p><p> <code>man7</code> 杂项</p><p> <code>man8</code> 管理类命令</p><p>有些关键字在不止一个章节中</p><p>指导章节：man # [COMMAND]</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">man`命令配置文件`/etc/man.config</code></pre><p> <code>MANPATH /.../.../...</code></p><h4 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h4><p>Space，向文件尾翻屏:</p><p>b，向文件首部翻屏:</p><p>d，向文件尾部翻半屏:</p><p>u，向文件首部翻半屏:</p><p>RETURN，向文件尾部翻一行</p><p>y ，向文件首部翻一行</p><p>q ，退出</p><h3 id="p"><a href="#p" class="headerlink" title="p"></a><code>p</code></h3><h3 id="wd"><a href="#wd" class="headerlink" title="wd"></a><code>wd</code></h3><p> 查看当前位置的绝对路径</p><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a><code>ls</code></h3><p><code> -a</code> 显示所有文件包括隐藏</p><p><code>-l</code>以列表的形式</p><p>​    <img src="https://oss.jayce.icu/markdown/202201062242168.png" alt="image-20220106224229321"></p><p>​    d：目录   -：文件   l：软连接</p><p><code>-h</code> humman人性化，字节大小带上单位</p><p><code>-d</code> 显示目录本身</p><p><img src="https://oss.jayce.icu/markdown/202201062251334.png" alt="image-20220106225118919"></p><p><code>-i</code> 查询文件号</p><h3 id="ln"><a href="#ln" class="headerlink" title="ln"></a><code>ln</code></h3><p>创建链接</p><p>软连接：类似于快捷方式  </p><p>硬链接：类似于拷贝，相比于cp -p  两个文件可以同时更新</p><p>删除源文件后，软连接不可访问，硬链接可以继续访问</p><p><code>-s</code>   soft 软连接</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">ln `-s` [源文件] [目标文件]</code></pre><h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a><code>mkdir</code></h3><p> 创建目录</p><p> -p 创建多级目录</p><h3 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a><code>rmdir</code></h3><p>删除空目录</p><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a><code>rm</code></h3><p><code>-r</code>递归删除</p><p><code>-f </code>强制删除</p><h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a><code>cp</code></h3><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">cp 1.txt /home</code></pre><p> <code>-r</code> 递归复制</p><p><code>-p</code> 保留文件属性，不会更改修改文件时间</p><p> <code>\cp</code>强制覆盖复制，不需要单独确认</p><h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a><code>mv</code></h3><p> 移动或重命名</p><p> 移动：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">mv /home/pig.txt /root</code></pre><p> 重命名：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">mv oldname newname</code></pre><h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a><code>touch</code></h3><p>新建文件 如果文件名中间需要空格，则必须用双引号</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">touch "program files"</code></pre><p>但尽量不要用空格作为文件名，很麻烦</p><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a><code>cat</code></h3><p> 查看文件内容</p><p> -n 显示行号</p><p>​    与cat相反的显示方法：<code>tac</code></p><p>​    <img src="https://oss.jayce.icu/markdown/202201091022043.png" alt="image-20220109102201471"></p><p> 配合 | more 按页显示文本内容</p><h3 id="more"><a href="#more" class="headerlink" title="more"></a><code>more</code></h3><ul><li>space 向下翻页</li><li>enter 向下翻行</li><li>q 退出</li><li>ctrl F 向下滚一屏</li><li>ctrl B 返回上一屏</li><li>= 输出当前行号</li><li>:f 输出文件名和当前行号</li></ul><h3 id="less"><a href="#less" class="headerlink" title="less"></a><code>less</code></h3><p>功能与more类似，但比more强大</p><p>less在显示文件内容时，根据显示需要进行加载内容，对大型文件有较高效率</p><ul><li>space 向下翻页</li><li>enter 向下翻行</li><li>q 退出</li><li>pageup</li><li>pagedown</li><li>/字串 向下搜寻【字串】功能：n：向下查找：N：向上查找</li><li>?字串 向上搜寻【字串】功能：n：向上查找：N：向下查找</li></ul><h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a><code>chmod</code></h3><p>语法：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">chmod [{ugoa}{+-=}{rwx}][文件/目录]chmod [mode=421][文件/目录]chmod -R 递归修改</code></pre><p>u(所有者) g(所属组) o(其他人) a(所有人)</p><p>+(增加) -(减少) =(赋予)</p><p>例如：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">chmod u+x,o-r start.shchmod (-R) 765 start.sh</code></pre><h3 id="echo"><a href="#echo" class="headerlink" title="echo"></a><code>echo</code></h3><p><code>&gt;</code>和<code>&gt;&gt;</code></p><p><code>&gt;</code>输出重定向</p><p><code>&gt;&gt;</code>追加</p><h3 id="history"><a href="#history" class="headerlink" title="history"></a><code>history</code></h3><p>记录历史操作</p><p>登陆shell时，会读取命令历史文件中记录下来的命令： ~/.bash_history</p><p>登陆进shell后，新执行的命令只会记录在缓存中</p><p>登出shell后，会被追加至记录里</p><ul><li><code>-a </code>更新历史记录文件</li><li><code>-d</code> 删除历史记录命令 <code>history -d 100</code></li><li><code>-c</code> 清空命令历史记录</li></ul><p>快捷操作：</p><p><code>!100</code> 运行第100行历史记录的命令</p><p><code>!string</code> 调用历史中最近一个以string开头的命令</p><p><code>!!</code> 重复运行上一条命令</p><h3 id="find"><a href="#find" class="headerlink" title="find"></a><code>find</code></h3><p>find命令是根据文件的属性进行查找</p><ul><li>文件名(-name)</li><li>文件大小(-size)</li><li>所有者(-user)</li><li>所属组(-group)</li><li>是否为空(-empty)</li><li>时间，time为日期（天），min为分钟，<strong>只有这两种</strong><pre><code>atime：访问时间（access time），指的是文件最后被读取的时间,可    以使用touch命令更改为当前时间；ctime：变更时间（change time），指的是文件本身最后被变更的时    间，变更动作可以使chmod、chgrp、mv等等；mtime：修改时间（modify time），指的是文件内容最后被修改的时间，修改动作可以使echo重定向、vi等等；</code></pre></li></ul><h4 id="文件名查找"><a href="#文件名查找" class="headerlink" title="文件名查找"></a>文件名查找</h4><ol><li><p><code>find / -name httpd.conf</code>　　</p><p>在根目录下查找文件httpd.conf，表示在整个硬盘查找</p></li><li><p><code>find /etc -name httpd.conf　</code>　</p><p>在/etc目录下文件httpd.conf</p></li><li><p><code>find /etc -name '</code>*srm*<code>'　</code>　</p><p>使用通配符*(0或者任意多个)。表示在/etc目录下查找文件名中含有字符串‘srm’的文件*</p></li><li><p><code>find . -name 'srm*'</code>　</p><p>表示当前目录下查找文件名开头是字符串‘srm’的文件</p></li></ol><h4 id="文件特征查找"><a href="#文件特征查找" class="headerlink" title="文件特征查找"></a>文件特征查找</h4><ol><li><p><code>find / -amin -10 </code>　</p><p>查找在系统中最后10分钟访问的文件(access time)</p></li><li><p><code>find / -atime -2　</code>　</p><p>查找在系统中最后48小时访问的文件</p></li><li><p><code>find / -empty </code></p><p>查找在系统中为空的文件或者文件夹</p></li><li><p><code>find / -group cat </code>　</p><p>查找在系统中属于 group为cat的文件</p></li><li><p><code>find / -mmin -5 </code></p><p>查找在系统中最后5分钟里修改过的文件(modify time)</p></li><li><p><code>find / -mtime -1 </code>　</p><p>查找在系统中最后24小时里修改过的文件</p></li><li><p><code>find / -user jayce </code>　</p><p>查找在系统中属于jayce这个用户的文件</p></li><li><p><code>find / -size +10000c</code>　</p><p>查找出大于10000000字节的文件</p><p>(c:字节，w:双字，k:KB，M:MB，G:GB)</p></li><li><p><code>find / -size -1000k</code> 　</p><p>查找出小于1000KB的文件</p></li></ol><h4 id="混合查找方式"><a href="#混合查找方式" class="headerlink" title="混合查找方式"></a>混合查找方式</h4><p>​    参数有：<code>!</code>，<code>-and(-a)</code>，<code>-or(-o)</code>。</p><ol><li><p><code>find /tmp -size +10000c -and -mtime +2</code> 　</p><p>在/tmp目录下查找大于10000字节并在最后2分钟内修改的文件</p></li><li><p><code>find / -user fred -or -user jayce </code>　　</p><p>在<code>/</code>目录下查找用户是fred或者jayce的文件文件</p></li><li><p><code>find /tmp ! -user jayce</code>　　</p><p>在<code>/tmp</code>目录中查找所有不属于jayce用户的文件</p></li></ol><h3 id="which"><a href="#which" class="headerlink" title="which"></a><code>which</code></h3><p>查看可执行文件的位置 ，只有设置了环境变量的程序才可以用</p><h3 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a><code>whereis</code></h3><p> 寻找特定文件，只能用于查找二进制文件、源代码文件和man手册页</p><h3 id="locate"><a href="#locate" class="headerlink" title="locate"></a><code>locate</code></h3><p>配合数据库查看文件位置 ,详情：locate -h查看帮助信息</p><h3 id="cut"><a href="#cut" class="headerlink" title="cut"></a><code>cut</code></h3><p>显示每行内容</p><p>由此可以实现提取每一行的第n个字符</p><p>参数：</p><ul><li><p>-b  以字节为单位进行分割</p></li><li><p>-c  以字符为单位进行分割</p></li><li><p>-d  自定义分隔符</p></li><li><p>-f  与-d一起使用，指定显示哪个区域</p><p>实例：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">cut -d "%" -f 1</code></pre><p>以%为分隔符，截取百分号前面的数值 -f 取截取后的第一行</p></li></ul><h3 id="alias"><a href="#alias" class="headerlink" title="alias"></a><code>alias</code></h3><p>alias 可以为命令指定别名，所谓别名可以省去一长串命令的麻烦</p><h4 id="查看别名"><a href="#查看别名" class="headerlink" title="查看别名"></a>查看别名</h4><p>直接使用命令<code>alias</code>可以查看所有的别名，如果想看某一命令，在alias后跟命令即可</p><p><a href="https://camo.githubusercontent.com/091bb781563ad6dfdefbd2a1dbf0c6836ac731ccce984e47230f15be1207a65d/68747470733a2f2f6a6179636568652e6f73732d636e2d68616e677a686f752e616c6979756e63732e636f6d2f6d61726b646f776e2f3230323230323134313532333133382e706e67"><img src="https://oss.jayce.icu/markdown/202203171533539.png" alt="image-20220214152355809"></a></p><h4 id="创建别名"><a href="#创建别名" class="headerlink" title="创建别名"></a>创建别名</h4><p>例如：</p><pre class="line-numbers language-none"><code class="language-none">alias newcmd='cmd'alias install='sudo apt-getinstall'</code></pre><p>上述方式一旦关闭终端，设置的别名就失效了</p><p>可以将命令放入 <del>/.bashrc 中，当每个进程生成时，都要执行`</del>/.bashrc`中的命令</p><h4 id="删除别名"><a href="#删除别名" class="headerlink" title="删除别名"></a>删除别名</h4><p><code>unalias</code> 命令可以将之前的别名删除</p><pre class="line-numbers language-none"><code class="language-none">unalias vi</code></pre><p>使用<code>-a</code>参数可以清除所有的别名</p><h4 id="不使用别名"><a href="#不使用别名" class="headerlink" title="不使用别名"></a>不使用别名</h4><p>当我们为命令加上日常参数后，但有时需要使用原始的命令时，有三种方法可以调用原始命令</p><ol><li>使用命令的绝对路径</li><li>切换命令所在目录，使用<code>./cmd</code></li><li>在命令前使用反斜线<code>\</code></li></ol><h4 id="别名永久生效"><a href="#别名永久生效" class="headerlink" title="别名永久生效"></a>别名永久生效</h4><p>我们通过 alias 命令设置的别名，仅限于在当前的 Shell 中使用，如果系统重启了，那么新设置的别名就失效了。</p><p>如果想让别名永久有效的话，就需要把所有的别名设置方案加入到（$HOME）目录下的 .alias 文件中（如果系统中没有这个文件，你可以创建一个），然后在 .bashrc 文件中增加这样一段代码：</p><pre class="line-numbers language-none"><code class="language-none"># Aliasesif [ -f ~/.alias ]; then  . ~/.aliasfi</code></pre><p>.alias文件：</p><pre class="line-numbers language-none"><code class="language-none">vim .alias######alias tf='tail -f'  #动态查看文件变化</code></pre><p>执行<code>source ~/.bashrc</code></p><h3 id="top"><a href="#top" class="headerlink" title="top"></a><code>top</code></h3><p>Linux top命令用于实时显示 process 的动态。</p><h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a><strong>参数说明</strong></h4><ul><li><p>d : 改变显示的更新速度，或是在交谈式指令列( interactive command)按 s</p></li><li><p>q : 没有任何延迟的显示速度，如果使用者是有 superuser 的权限，则 top 将会以最高的优先序执行</p></li><li><p>c : 切换显示模式，共有两种模式，一是只显示执行档的名称，另一种是显示完整的路径与名称</p></li><li><p>S : 累积模式，会将己完成或消失的子进程 ( dead child process ) 的 CPU time 累积起来</p></li><li><p>s : 安全模式，将交谈式指令取消, 避免潜在的危机</p></li><li><p>i : 不显示任何闲置 (idle) 或无用 (zombie) 的进程</p></li><li><p>n : 更新的次数，完成后将会退出 top  <strong><code>top -n 3</code></strong></p></li><li><p>b : 批次档模式，搭配 “n” 参数一起使用，可以用来将 top 的结果输出到档案内</p><ul><li><p>输出到文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">top -n 1 -b &gt; top.txt</code></pre></li></ul></li></ul><p><img src="https://oss.jayce.icu/markdown/202203171611873.png" alt="image-20220317161136480"></p><h4 id="各行解析"><a href="#各行解析" class="headerlink" title="各行解析"></a>各行解析</h4><blockquote><p><strong>top - 16:11:14 up 40 days, 15:34,  1 user,  load average: 0.01, 0.03, 0.05</strong><br><strong>Tasks:  94 total,   1 running,  93 sleeping,   0 stopped,   0 zombie</strong><br><strong>%Cpu(s):  0.0 us,  3.2 sy,  0.0 ni, 96.8 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</strong><br><strong>KiB Mem :  1776196 total,    72544 free,  1545768 used,   157884 buff/cache</strong><br><strong>KiB Swap:        0 total,        0 free,        0 used.    79840 avail Mem</strong></p></blockquote><p>第一行</p><table><thead><tr><th align="left">内容</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">16:11:14</td><td align="left">表示当前时间</td></tr><tr><td align="left">up 40days，15:34</td><td align="left">系统运行时间 不指定格式为时：分</td></tr><tr><td align="left">1 users</td><td align="left">当前登录用户数</td></tr><tr><td align="left">load average: 0.01, 0.03, 0.05</td><td align="left">系统负载，即任务队列的平均长度。 三个数值分别为 1分钟、5分钟、15分钟前到现在的平均值。<strong>如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了</strong></td></tr></tbody></table><p>第二行</p><table><thead><tr><th align="left">内容</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">94 total</td><td align="left">进程总数</td></tr><tr><td align="left">1 running</td><td align="left">正在运行的进程数</td></tr><tr><td align="left">93 sleeping</td><td align="left">睡眠的进程数</td></tr><tr><td align="left">0 stopped</td><td align="left">停止的进程数</td></tr><tr><td align="left">0 zombie</td><td align="left">僵尸进程数</td></tr></tbody></table><p>第三行</p><p>%Cpu(s):  0.0 us,  3.2 sy,  0.0 ni, 96.8 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</p><table><thead><tr><th align="left">内容</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">0.0 us</td><td align="left">用户空间占用CPU百分比</td></tr><tr><td align="left">3.2 sy</td><td align="left">内核空间占用CPU百分比</td></tr><tr><td align="left">0.0 ni</td><td align="left">用户进程空间内改变过优先级的进程占用CPU百分比</td></tr><tr><td align="left">96.8 id</td><td align="left">空闲CPU百分比</td></tr><tr><td align="left">0.0 wa</td><td align="left">等待输入输出的CPU时间百分比</td></tr><tr><td align="left">0.0 hi</td><td align="left">硬中断（Hardware IRQ）占用CPU的百分比</td></tr><tr><td align="left">0.0 si</td><td align="left">软中断（Software Interrupts）占用CPU的百分比</td></tr><tr><td align="left">0.0 st</td><td align="left"></td></tr></tbody></table><p>第四行</p><p>KiB Mem :  1776196 total,    72544 free,  1545768 used,   157884 buff/cache</p><table><thead><tr><th align="left">内容</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">KiB Mem :  1776196 total</td><td align="left">物理内存总</td></tr><tr><td align="left">72544 free</td><td align="left">空闲内存总量</td></tr><tr><td align="left">1545768 used</td><td align="left">使用的物理内存总量</td></tr><tr><td align="left">157884 buff/cache</td><td align="left">用作内核缓存的内存量</td></tr></tbody></table><p>第五行</p><p>KiB Swap:        0 total,        0 free,        0 used.    79840 avail Mem</p><table><thead><tr><th align="left">内容</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">KiB Swap:        0 total</td><td align="left">交换区总量</td></tr><tr><td align="left">0 free</td><td align="left">空闲交换区总量</td></tr><tr><td align="left">0 used</td><td align="left">使用的交换区总量</td></tr><tr><td align="left">79840 avail Mem</td><td align="left">代表可用于进程下一次分配的物理内存数量</td></tr></tbody></table><table><thead><tr><th>列名</th><th>含义</th></tr></thead><tbody><tr><td>PR</td><td>优先级</td></tr><tr><td>NI</td><td>nice值。负值表示高优先级，正值表示低优先级</td></tr><tr><td>VIRT</td><td>进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</td></tr><tr><td>RES</td><td>进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA</td></tr><tr><td>SHR</td><td>共享内存大小，单位kb</td></tr><tr><td>S</td><td>进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程</td></tr><tr><td>%CPU</td><td>上次更新到现在的CPU时间占用百分比</td></tr><tr><td>%MEM</td><td>进程使用的物理内存百分比</td></tr><tr><td>TIME+</td><td>进程使用的CPU时间总计，单位1/100秒</td></tr><tr><td>COMMAND</td><td>命令名/命令行</td></tr></tbody></table><hr><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a><code>sort</code></h3><p>对文本内容排序，以行为单位，默认以第一列ASCII 码的次序排列</p><p>重点参数说明</p><ul><li><p><code>-b</code> 忽略每行前面开始出的空格字符。</p></li><li><p><code>-r</code> 以相反的顺序来排序。</p></li><li><p><code>-k n</code>    按指定的<strong>列</strong>进行排序。</p></li><li><p><code>-u</code>去重</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">sort a.txtsort testfile -k 2</code></pre></li></ul><p>注意，sort排序后需要重定向输出</p><h4 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a><code>uniq</code></h4><p>排序后去重</p><h3 id="iconv"><a href="#iconv" class="headerlink" title="iconv"></a><span id="#iconv"><code>iconv</code></span></h3><p>对于给定文件把它的内容从一种编码转换成另一种编码。 </p><p>-f </p><pre class="line-numbers language-none"><code class="language-none">iconv -c -t utf-8 test.txt -o tmp.txt</code></pre><h3 id="tee"><a href="#tee" class="headerlink" title="tee"></a><code>tee</code></h3><p>既可以重定向到文件，还可以建立副本传向后续的stdin</p><p>（即打印输出又写入文件）</p><p>-a 选项为追加内容，类似&gt;&gt;</p><h3 id="comm"><a href="#comm" class="headerlink" title="comm"></a><code>comm</code></h3><p>Linux comm 命令用于比较两个已排过序的文件。</p><ul><li>-1 不显示只在第 1 个文件里出现过的列。</li><li>-2 不显示只在第 2 个文件里出现过的列。</li><li>-3 不显示交集列。</li></ul><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">comm a.txt b.txt</code></pre><h3 id="curl"><a href="#curl" class="headerlink" title="curl"></a><code>curl</code></h3><p>支持http https ftp等众多请求</p><p>直接curl + 地址 ，可输出网页源码</p><p>保存网页源码：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">curl -o linux.html https://jayce.icucurl https://jayce.icu &gt;&gt; jayce.html</code></pre><p>下载网页文件（不如用wget）</p><pre class="line-numbers language-none"><code class="language-none">curl -O https://jayce.icu/hello.sh</code></pre><p>使用代理服务器：</p><pre class="line-numbers language-none"><code class="language-none">curl -x 127.0.0.1:10809 https://jayce.icu</code></pre><h2 id="Linux三剑客"><a href="#Linux三剑客" class="headerlink" title="Linux三剑客"></a>Linux三剑客</h2><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a><code>grep</code></h3><h4 id="主要参数"><a href="#主要参数" class="headerlink" title="主要参数"></a>主要参数</h4><p>[options]主要参数：</p><p>​    <code>-c</code>：只输出匹配行的计数。(count)</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">grep -c ftp /etc/passwd</code></pre><p><img src="https://oss.jayce.icu/markdown/202201111617840.png" alt="image-20220111161732807"></p><p>​    <code>-i</code>：不区分大小写 </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">grep -i FTP /etc/passwd</code></pre><p><img src="https://oss.jayce.icu/markdown/202201111617063.png" alt="image-20220111161753629"></p><p>​    <code>-h</code>：查询多文件时不显示文件名。</p><p><img src="https://oss.jayce.icu/markdown/202201111626834.png" alt="image-20220111162602191"></p><p>​    <code>-l</code>：查询多文件时只输出包含匹配字符的文件名。</p><p><img src="https://oss.jayce.icu/markdown/202201111626791.png" alt="image-20220111162624906"></p><p>​    <code>-n</code>：显示匹配行及行号。</p><p><img src="https://oss.jayce.icu/markdown/202201111626789.png" alt="image-20220111162658201"></p><p>​    <code>-s</code>:   不显示不存在或无匹配文本的错误信息。</p><p>​    <code>-v</code>：显示不包含匹配文本的所有行。</p><h4 id="输出相邻行"><a href="#输出相邻行" class="headerlink" title="输出相邻行"></a>输出相邻行</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">grep -A 1 bash oss.shgrep -B 2 bash oss.shgrep -C 3 bash oss.sh</code></pre><p><img src="https://oss.jayce.icu/markdown/202201111631651.png" alt="image-20220111163121166"></p><p><img src="https://oss.jayce.icu/markdown/202201111633711.png" alt="image-20220111163355721"></p><p><img src="https://oss.jayce.icu/markdown/202201111634820.png" alt="image-20220111163437416"></p><p>总结：</p><p><code>-A</code>选项，是 After 的缩写<strong>查看后面</strong></p><p><code>-B</code>选项，是 Before 的缩写查看前面</p><p><code>-C</code>选项，它是<code>-A</code>和<code>-B</code>选项的合体<strong>两边都看</strong></p><h4 id="zgrep"><a href="#zgrep" class="headerlink" title="zgrep"></a>zgrep</h4><p>zgrep 和 grep 用法类似，不过操作的对象是压缩的内容。支持 bzip2，gzip，lzip， xz 等等。</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">zgrep "/api" access_log.gz access_log_1.gz</code></pre><hr><h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a><code>awk</code></h3><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">awk '条件1{动作1} 条件2{动作2}..' filename </code></pre><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">df -h|grep "vda1"|awk '{printf $5 "\t\n"}'|cut -d "%" -f 1</code></pre><p>按照指定符号分割：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">awk -F "." '{print $1}'#复杂写法awk 'BEGIN{FS="|";OFS="|"}{print $1,$2,$3,$4}' informix.txt</code></pre><h4 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h4><h5 id="BEGIN"><a href="#BEGIN" class="headerlink" title="BEGIN"></a>BEGIN</h5><p>在所有数据读取之前执行这条命令</p><p>awk默认先读取第一行数据，如果</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">ps -ef|grep sshd|awk 'BEGIN{printf "输出进程号\n"} {print $2}'</code></pre><p><img src="https://oss.jayce.icu/markdown/202201221720695.png" alt="image-20220122172009408"></p><p>如果没有BEGIN，则输出为</p><p><img src="https://oss.jayce.icu/markdown/202203171054281.png" alt="image-20220317105404238"></p><p>由此可见，BEGIN后的第一行是默认直接读取一次，不影响后面。</p><h5 id="END"><a href="#END" class="headerlink" title="END"></a>END</h5><p>与BEGIN类似，读取最后一行</p><p>指定分隔符截取：</p><p>FS：输入分隔符</p><p>OFS：输出分隔符</p><p><strong>多个分隔符：FS=“[,.]”  先以<code>,</code>分再以<code>.</code>分</strong></p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">awk 'BEGIN{FS="|";OFS="|"}{print $1,$2,$3,$4}' informix.txt</code></pre><p><img src="https://oss.jayce.icu/markdown/202203171119258.png" alt="image-20220317111917170"></p><p>取出IP：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ifconfig eth0|grep -w 'inet'|awk 'BEGIN{FS="[. ]"}{print $10$11$12$13}'</code></pre><h3 id="sed"><a href="#sed" class="headerlink" title="sed"></a><code>sed</code></h3><p>sed利用脚本处理文本文件</p><p>语法：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sed [选项][脚本命令]文本文件</code></pre><h4 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h4><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-e 脚本命令</td><td>该选项会将其后跟的脚本命令添加到已有的命令中。</td></tr><tr><td>-f 脚本命令文件</td><td>该选项会将其后文件中的脚本命令添加到已有的命令中。</td></tr><tr><td>-n</td><td>默认情况下，sed 会在所有的脚本指定执行完毕后，会自动输出处理后的内容，而该选项会屏蔽启动输出，需使用 print 命令来完成输出。</td></tr><tr><td>-i</td><td>此选项会直接修改源文件，要慎用。</td></tr></tbody></table><h4 id="脚本命令"><a href="#脚本命令" class="headerlink" title="脚本命令"></a>脚本命令</h4><p>address 表示指定要操作的具体行</p><p>pattern 指的是需要替换的内容</p><p>replacement 指的是要替换的新内容</p><p>flag标记如下：</p><table><thead><tr><th>flags 标记</th><th>功能</th></tr></thead><tbody><tr><td>n</td><td>1~512 之间的数字，表示指定要替换的字符串出现第几次时才进行替换，例如，一行中有 3 个 A，但用户只想替换第二个 A，这是就用到这个标记；</td></tr><tr><td>g</td><td>对数据中所有匹配到的内容进行替换，如果没有 g，则只会在第一次匹配成功时做替换操作。例如，一行数据中有 3 个 A，则只会替换第一个 A；</td></tr><tr><td>p</td><td>会打印与替换命令中指定的模式匹配的行。此标记通常与 -n 选项一起使用。</td></tr><tr><td>w file</td><td>将缓冲区中的内容写到指定的 file 文件中；</td></tr><tr><td>&amp;</td><td>用正则表达式匹配的内容进行替换；</td></tr><tr><td>\n</td><td>匹配第 n 个子串，该子串之前在 pattern 中用 () 指定。</td></tr><tr><td>\</td><td>转义（转义替换部分包含：&amp;、\ 等）。</td></tr></tbody></table><ul><li><p><strong>a</strong> ：新增， 表示在指定行的<strong>后面</strong>附加一行</p><p>实例：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[address]a（或 i）\新文本内容sed -e 4a\newLine mysql.txt</code></pre><p><img src="https://oss.jayce.icu/markdown/202203171419483.png" alt="image-20220317141941485"></p><p>但是如果该文件不够4行，则：</p><p><img src="https://oss.jayce.icu/markdown/202203171421901.png" alt="image-20220317142110038"></p></li><li><p><strong>c</strong> ：替换整行</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">[address]c\用于替换的新文本sed '3c\changed line' a.txt</code></pre><p><img src="https://oss.jayce.icu/markdown/202203171522091.png" alt="image-20220317152219121"></p></li><li><p><strong>d</strong> ：删除，因为是删除啊，所以 d 后面通常不接任何东东；</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[address]dsed 'd' a.txt #什么也不输出，证明成了空文件sed '3d' a.txt #删除第三行sed '2,3d' a.txt sed '/1/,/3/d' a.txt sed '3,$d' a.txt     #删除第三行之后所有的内容</code></pre></li></ul><p>​     <strong>在默认情况下 sed 并不会修改原始文件</strong></p><ul><li><p><strong>i</strong> ：新增， i 命令表示在指定行的<strong>前面</strong>插入一行，用法同a。</p></li><li><p><strong>p</strong> ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～</p></li><li><p><strong>s</strong> ：取代，replace</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">[address]s/pattern/replacement/flagssed '2s/first/second/2' a.txt</code></pre><pre class="line-numbers language-none"><code class="language-none">sed 's/a/z/2' a.txt</code></pre><p>使用数字 2 作为标记的结果就是，sed 编辑器只替换每行中第 2 次出现的匹配模式。如果需要替换所有的字符串，需要用g标记</p><p>注意：在使用 s 脚本命令时，替换类似文件路径的字符串会比较麻烦，需要将路径中的正斜线进行转义，例如：</p><pre class="line-numbers language-none"><code class="language-none">sed 's/\/bin\/bash/\/bin\/csh/' /etc/passwd</code></pre><p>去除转义字符后，红线为格式</p><p><code>sed 's<span style="color:red">/</span>/bin/bash<span style="color:red">/</span>/bin/csh<span style="color:red">/</span>' /etc/passwd</code></p></li><li><p><strong>y</strong>：y转换可以处理单个字符，对 inchars 和 outchars 值进行一对一的映射，为全局转换</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">[address]y/inchars/outchars/sed 'y/123/789/' loop.txt</code></pre><p>命令将把1对应替换为7，2对应替换为8，3对应替换为9</p></li></ul><p><img src="https://oss.jayce.icu/markdown/202203171528298.png" alt="image-20220317152759451"></p><h2 id="VIM"><a href="#VIM" class="headerlink" title="VIM"></a>VIM</h2><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>即进入vim时的模式，可以进行dd，i等操作</p><p><img src="https://oss.jayce.icu/markdown/202203301444832.png" alt="image-20220330144425674"></p><p>常用命令：</p><ul><li><code>i</code> 切换至输入模式</li><li><code>x</code> 删除当前字符</li><li><code>:</code> 切换底线命令模式</li></ul><table><thead><tr><th>移动光标</th><th></th></tr></thead><tbody><tr><td>H</td><td><strong>屏幕</strong>的最上方一行的第一个字</td></tr><tr><td>M</td><td><strong>屏幕</strong>的中央一行的第一个字</td></tr><tr><td>L</td><td><strong>屏幕</strong>的最下方一行的第一个字</td></tr><tr><td>G</td><td><strong>档案</strong>的最后一行(常用)</td></tr><tr><td>nG</td><td>n 为数字。移动到这个档案的第 n 行</td></tr><tr><td>gg</td><td>移动到这个<strong>档案</strong>的第一行，相当于 1G (常用)</td></tr><tr><td>n<enter></enter></td><td>n 为数字。光标向下移动 n 行(常用)</td></tr></tbody></table><table><thead><tr><th align="left">搜索替换</th><th></th></tr></thead><tbody><tr><td align="left">/word</td><td>向<strong>光标之下</strong>寻找一个名称为 word 的字符串</td></tr><tr><td align="left">?word</td><td>向<strong>光标之上</strong>寻找一个名称为 word 的字符串</td></tr><tr><td align="left">n</td><td>这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！</td></tr><tr><td align="left">N</td><td>这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。</td></tr><tr><td align="left">使用 /word 配合 n 及 N 是非常有帮助的！可以让你重复的找到一些你搜寻的关键词！</td><td></td></tr><tr><td align="left"><code>:n1,n2s/word1/word2/g</code></td><td>n1 与 n2 为数字。<br>在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： <code>:100,200s/vbird/VBIRD/g</code>(常用)</td></tr><tr><td align="left"><code>:1,$s/word1/word2/g</code>或 <code>:%s/word1/word2/g</code></td><td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)</td></tr><tr><td align="left"><code>:1,$s/word1/word2/gc</code>或 <code>:%s/word1/word2/gc</code></td><td>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！<br><strong>且在取代前显示提示字符给用户确认 (confirm) 是否需要取代！(常用)</strong></td></tr></tbody></table><table><thead><tr><th align="left">删除、复制与粘贴</th><th></th></tr></thead><tbody><tr><td align="left"><strong>n</strong>x</td><td>n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。</td></tr><tr><td align="left">dd</td><td>剪切游标所在的那一整行(常用)，用 p/P 可以粘贴。</td></tr><tr><td align="left"><strong>n</strong>dd</td><td>n 为数字。剪切光标所在的向下 n 行，例如 20dd 则是剪切 20 行(常用)，用 p/P 可以粘贴。</td></tr><tr><td align="left">d<strong>n</strong>G</td><td><strong>删除</strong>光标所在到第<strong>n</strong>行的所有数据</td></tr><tr><td align="left">dG</td><td><strong>删除</strong>光标所在到最后一行的所有数据</td></tr><tr><td align="left">d$</td><td><strong>删除</strong>游标所在处，到该行的最后一个字符</td></tr><tr><td align="left">d0</td><td>那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符</td></tr><tr><td align="left">yy</td><td>复制游标所在的那一行(常用)</td></tr><tr><td align="left">nyy</td><td>n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行(常用)</td></tr><tr><td align="left">y<strong>n</strong>G</td><td>复制游标所在行到第一行的所有数据</td></tr><tr><td align="left">yG</td><td>复制游标所在行到最后一行的所有数据</td></tr><tr><td align="left">y0</td><td>复制光标所在的那个字符到该行行首的所有数据</td></tr><tr><td align="left">y$</td><td>复制光标所在的那个字符到该行行尾的所有数据</td></tr><tr><td align="left">p, P</td><td>p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)</td></tr><tr><td align="left">u</td><td>复原前一个动作。(常用)</td></tr></tbody></table><h3 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h3><h3 id="底线命令模式"><a href="#底线命令模式" class="headerlink" title="底线命令模式"></a>底线命令模式</h3><h4 id="保存与退出"><a href="#保存与退出" class="headerlink" title="保存与退出"></a>保存与退出</h4><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><code>:w</code></td><td>将编辑的数据写入硬盘档案中(常用)</td></tr><tr><td><code>:w!</code></td><td>若文件属性为『只读』时，强制写入该档案。</td></tr><tr><td><code>:q</code></td><td>离开 vi (常用)</td></tr><tr><td><code>:q!</code></td><td>! 为强制离开不储存档案。</td></tr><tr><td><code>:wq</code></td><td>储存后离开，wq! 则为强制储存后离开</td></tr><tr><td><code>:w [filename]</code></td><td>将编辑的数据储存成另一个文件<br>（类似另存新档）</td></tr><tr><td><code>:r [filename]</code></td><td>读入另一个档案的数据。<br>将 [filename]内容加到游标所在行后面</td></tr><tr><td><code>:n1,n2 w [filename]</code></td><td>将 n1 到 n2 的内容储存成 filename 这个档案。</td></tr><tr><td><code>:! command</code></td><td>暂时离开 vi 到终端执行 command 的显示结果！</td></tr></tbody></table><h4 id="查看与设置编码"><a href="#查看与设置编码" class="headerlink" title="查看与设置编码"></a>查看与设置编码</h4><p>查看</p><pre class="line-numbers language-none"><code class="language-none">:set fileencoding</code></pre><p>设置</p><pre class="line-numbers language-none"><code class="language-none">:set fileencoding=utf-8</code></pre><p>如果不用vim，可以用专门转码的命令 iconv，导航👉<a href="#iconv">iconv</a> </p><h4 id="显示行号"><a href="#显示行号" class="headerlink" title="显示行号"></a>显示行号</h4><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>:set nu</td><td>显示行号，设定之后，会在每一行的前缀显示该行的行号</td></tr><tr><td>:set nonu</td><td>与 set nu 相反，为取消行号！</td></tr></tbody></table><h2 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h2><h3 id="连接-1"><a href="#连接-1" class="headerlink" title="连接"></a>连接</h3><p>ftp ip port</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ftp 192.168.1.1 21</code></pre><p>文件的上传和下载都会在连接命令所在的目录下，即在<code>/usr/local</code>下执行ftp，则文件都下载到了<code>/usr/local</code></p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><p>将文件从远端主机中传送至本地主机中</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">get /usr/local/1.txt</code></pre><h4 id="mget"><a href="#mget" class="headerlink" title="mget"></a>mget</h4><p>从远端主机接收一批文件至本地主机</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">cd /usr/your/mget *.*</code></pre><p>在<code>mget</code>命令前先执行<code>:prompt off</code>，可去除每次提示</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于mysql数据库</title>
      <link href="//post/mysql.html"/>
      <url>//post/mysql.html</url>
      
        <content type="html"><![CDATA[<h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><p>[TOC]</p><h2 id="Mysql运行原理"><a href="#Mysql运行原理" class="headerlink" title="Mysql运行原理"></a>Mysql运行原理</h2><h3 id="bin目录"><a href="#bin目录" class="headerlink" title="bin目录"></a>bin目录</h3><p><img src="https://oss.jayce.icu/markdown/image-20221116143129853.png" alt="image-20221116143129853"></p><p>mysqld：直接启动一个mysql服务器进程</p><p>mysql_safe ：启动脚本，会间接调用mysqld，并持续监控服务器运行状态，当进程出现问题，可以帮助重启服务器，还可以输出错误日志。</p><p>mysql.server：启动脚本，间接调用mysql_safe，可在后面加入start参数来启动服务器。</p><p>mysqld_multi：启动脚本，可以启动和停止多个mysql进程</p><h3 id="mysql连接"><a href="#mysql连接" class="headerlink" title="mysql连接"></a>mysql连接</h3><p>mysql采用tcp作为服务器与客户端的网络通信协议，mysql启动时会默认申请3306端口，等待客户端连接，如需更改，可以在启动时加上-P参数</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">mysqld -P3307</code></pre><p>登陆mysql</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">mysql -h ip -P 3306 -uroot -p([密码)</code></pre><h4 id="UNIX域套接字"><a href="#UNIX域套接字" class="headerlink" title="UNIX域套接字"></a>UNIX域套接字</h4><p>如果服务器和客户端都在类UNIX的同一台机器，可以使用<strong>UNIX域套接字</strong>进行通信</p><p>mysql服务器程序默认监听的UNIX域套接字文件名称是<code>/tmp/mysql.sock</code></p><p>如需更改，在启动服务器时，指定socket参数</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">mysqld --socket=path</code></pre><p>如果客服端想通过UNIX域套接字进行通讯，也需要显式指定UNIX域套接字文件名称</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql -hlocalhost  -uroot --socket=path  -p </code></pre><h4 id="处理请求过程"><a href="#处理请求过程" class="headerlink" title="处理请求过程"></a>处理请求过程</h4><p><img src="https://oss.jayce.icu/markdown/image-20221116150854394.png" alt="image-20221116150854394"></p><h5 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h5><p>每个客户端连接服务器时，服务器会创建一个线程，专门处理与这个客户端的交互。</p><p>当客户端退出时，服务器不会立即销毁线程，而是缓存起来，在另一个新的客户端再连接时，把这个线程分配给新的客户端。</p><p>从而不会去反复创建和销毁</p><h5 id="解析与优化"><a href="#解析与优化" class="headerlink" title="解析与优化"></a>解析与优化</h5><h6 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h6><p>如果查询请求中出现重复的查询，mysql第一次会把查询结果和请求缓存起来，后续的重复请求会直接查询缓存中的请求和结果。</p><p>但如果请求有所不同则不会识别，系统函数，自定义变量，系统表这类请求不会被缓存。</p><p>mysql缓存系统会监控每张表，如果表数据或结构被修改，则删除缓存。</p><h6 id="语法解析"><a href="#语法解析" class="headerlink" title="语法解析"></a>语法解析</h6><p>没有查询到缓存后，mysql会对查询语句分析，判断其是否正确，然后将需要查询的表和条件提取出来，放在mysql内部使用的一些数据结构上。</p><h6 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h6><p>将语句进行优化，方法包括转换连接，表达式简化等。</p><p>可以通过<code>EXPLAIN</code> 来查看查询计划。</p><h5 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h5><p>常用的时InnoDB和MyISAM，InnoDB是mysql的默认引擎（5.5.5版本以后，之前为MyISAM）</p><p>设置存储引擎</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">CREATE TABLE table_name() ENGINE = MyISAM ;</code></pre><p>修改存储引擎</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">ALTER TABLE table_name ENGINE = MyISAM ;</code></pre><h4 id="连接白名单"><a href="#连接白名单" class="headerlink" title="连接白名单"></a>连接白名单</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">use mysqlselect user,host from user</code></pre><p>看root用户的host是否为localhost</p><p>如果为localhost，则只能本地登陆，所以要将localhost改为可以远程的ip</p><p>如果是指定的IP，可以用：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">grant all privileges on *.* to 'root'@'[允许的ip]' identified by '[密码]' with grant option;flush privileges; </code></pre><p>通过所有IP</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">grant all privileges on *.* to 'root'@'%' identified by 'root' with grant option;flush privileges;</code></pre><h3 id="Mysql-配置与启动"><a href="#Mysql-配置与启动" class="headerlink" title="Mysql 配置与启动"></a>Mysql 配置与启动</h3><h4 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h4><p>选项名前加<code>--</code>  , 如果选项名是多个单词，可以用<code>-</code> 或<code>_</code>连接</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">mysqld --skip-networking --default-strage-engine=MyISAM#选项名，= ， 选项值直接不能有空格</code></pre><p>skip-networking  :   禁止使用TCP/IP 网络通信</p><p>default-strage-engine :  设置默认引擎</p><p>更多选项执行<code>mysql --help</code> 查看</p><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>my.cof</p><p>配置文件寻找排序</p><p><code>/etc/my.cnf</code> &gt;  <code>/etc/mysql/my.cnf</code>&gt; <code>SYSCONFDIR/my.cnf</code>&gt; <code>$MYSQL_HOME/my.cnf</code></p><p>SYSCONFDIR是使用CMake构建Mysql时指定的目录</p><h5 id="配置文件格式"><a href="#配置文件格式" class="headerlink" title="配置文件格式"></a>配置文件格式</h5><pre class="line-numbers language-none"><code class="language-none">[server]option 1option 2 = value 2[mysqld][client][mysqladmin]</code></pre><p>不同的选项组给不同的程序使用，除了[server]和[client] 分别作用与服务器和客户端</p><p>mysqld_safe 和 mysql.server 都会读取[mysqld]。</p><h5 id="配置文件优先级"><a href="#配置文件优先级" class="headerlink" title="配置文件优先级"></a>配置文件优先级</h5><p>mysql会按上面提到过的顺序搜索文件.</p><p>但也可以使用<code>--defaults-file</code>指定配置文件,如果我呢见无法正常读取则会报错.</p><p>也可以使用<code>--defaults-extra-file</code>指定<strong>额外的</strong>配置文件``</p><p><strong>如果多个配置文件有相同启动项，则以最后一个为准</strong></p><p> <strong>在同一个配置文件有相同启动项，则以最后一个出现组中的启动项为准</strong></p><p><strong>命令行比配置文件优先级高</strong></p><h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h3><p>查看系统变量:</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">show global|session variables like ''#此处选项名的各个单词之间必须要下划线_#不指定global|session ,默认session</code></pre><p><img src="https://oss.jayce.icu/markdown/image-20221116163012969.png" alt="image-20221116163012969"></p><p>修改系统变量:</p><ol><li><p>启动时加入参数</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">mysqld --max-connections=1000</code></pre></li><li><p>配置文件</p><pre class="line-numbers language-none"><code class="language-none">[server]max-connections=1000</code></pre></li><li><p>SET(服务运行时)</p><ol><li><p>GLOBAL 全局</p></li><li><p>SESSION 会话</p></li></ol><p>服务器在启动时会把每个全局变量设置为默认</p><p>语法</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">set [global|session]  option = value;set [@@(global|session).]  option = value;#举例set global default_strage_engine = MyISAM;set @@global.default_strage_engine = MyISAM;set default_strage_engine = MyISAM;  #不指定默认session</code></pre></li></ol><p><strong>注意❗:</strong></p><p><strong>不是所有的系统变量都有global和session的作用范围，有些只有global，有些只有session，大部分都有</strong></p><p><strong>有些系统变量只读，不可修改</strong></p><p>状态变量</p><p>show global status like ‘Max_used_connections’;</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="ubuntu"><a href="#ubuntu" class="headerlink" title="ubuntu"></a>ubuntu</h3><p>系统：Ubuntu16.04</p><pre class="line-numbers language-none"><code class="language-none">apt-get updateapt-get install mysql-server</code></pre><p>需要注意的是，在安装mysql 后是不可以使用navicat等远程工具进行连接的</p><p>默认安装后，3306端口只绑定给了localhost，所以外网是无法访问的</p><p>解决方法：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">vim /etc/mysql/mysql.conf.d/mysqld.cnf</code></pre><p>将bind-address   = 127.0.0.1注释掉</p><p><img src="https://jaycehe.oss-cn-hangzhou.aliyuncs.com/markdown/202109171525629.png" alt="image-20210721175850771"></p><p>重启即可</p><pre class="line-numbers language-none"><code class="language-none">systemctl restart mysql service mysql restart</code></pre><p> 接着授予权限：</p><h3 id="centos"><a href="#centos" class="headerlink" title="centos"></a>centos</h3><p>系统：centos7</p><p>下载mysql5.7的本地仓库文件</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">wget -i -c http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm</code></pre><p>将仓库信息添加至yum</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum -y install mysql57-community-release-el7-10.noarch.rpm</code></pre><p>接着在通过yum进行安装</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum -y install mysql-community-server --nogpgcheck</code></pre><p>此时mysql会取代mariadb</p><p>启动mysql服务</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">systemctl start mysqldsystemctl status mysqld</code></pre><p>此时的登陆密码存放在文件里，查看密码，用该初始化密码登录</p><pre class="line-numbers language-none"><code class="language-none">grep "A temporary password is generated" /var/log/mysqld.log|awk '{print $11}'</code></pre><p><img src="https://jaycehe.oss-cn-hangzhou.aliyuncs.com/markdown/202203091507458.png" alt="image-20220309150733851"></p><p>使用命令登录数据库后，修改该默认密码，否则无法使用</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">ALTER USER 'root'@'localhost' IDENTIFIED BY '$Password';</code></pre><p>其中，新密码必须使用大写，小写，数字和特殊字符组成</p><p>开启远程登录</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">grant all privileges on *.* to 'root'@'%' identified by 'password' with grant option;flush privileges; </code></pre><p>其中%代表所有ip，password替换为数据库密码。</p><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><h3 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">creat user 'jayce'@'host' identified by 'password'</code></pre><h3 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">alter user 'jayce'@'host' identified by 'password'</code></pre><h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><h4 id="查看用户权限"><a href="#查看用户权限" class="headerlink" title="查看用户权限"></a>查看用户权限</h4><pre class="line-numbers language-none"><code class="language-none">show grants for 'root'@'localhost';</code></pre><h4 id="授予权限"><a href="#授予权限" class="headerlink" title="授予权限"></a>授予权限</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">grant privileges on databasename.table to 'username'@'host';</code></pre><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">revoke privileges on databasename.table to 'username'@'host';</code></pre><h2 id="Mysql数据类型"><a href="#Mysql数据类型" class="headerlink" title="Mysql数据类型"></a>Mysql数据类型</h2><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>整数类型一共有 5 种，包括 TINYINT、SMALLINT、MEDIUMINT、INT（INTEGER）和 BIGINT。</p><table><thead><tr><th>整数类型</th><th>字节</th><th>有符号范围</th><th>无符号范围</th></tr></thead><tbody><tr><td>TINYINT</td><td>1</td><td>-128~127</td><td>0~255</td></tr><tr><td>SMALLINT</td><td>2</td><td>-32768~32767</td><td>0~65535</td></tr><tr><td>MEDIUMINT</td><td>3</td><td>-8388608~8388607</td><td>0~16777215</td></tr><tr><td>INT/INTEGER</td><td>4</td><td>-2147483648~2147483647</td><td>0~4294967295</td></tr><tr><td>BIGINT</td><td>8</td><td>-9223372036854775808~9223372036854775807</td><td>0~18446744073709551615</td></tr></tbody></table><p>参数：</p><p>括号数值的取值范围是(0, 255)。例如，int(5)：当数据宽度小于5位的时候在数字前面需要用字符填满宽度。</p><p>ZEROFILL 表示数字前面的字符宽度用0填充,（如果某列是ZEROFILL，那么MySQL会自动为当前列添加UNSIGNED属性）</p><p>UNSIGNED表示无符号类型（非负）</p><p>TINYINT有符号数和无符号数的取值范围分别为-128~ 127和0~255，由于负号占了一个数字位，因此TINYINT默认的显示宽度为4。同理，<strong>其他整数类型的默认显示宽度与其有符号数的最小值的宽度相同</strong>。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>（1）TINYINT ：一般用于枚举数据，比如系统设定取值范围很小且固定的场景。<br>（2）SMALLINT ：可以用于较小范围的统计数据，比如统计工厂的固定资产库存数量等。<br>（3）MEDIUMINT ：用于较大整数的计算，比如车站每日的客流量等。<br>（4）INT、INTEGER ：取值范围足够大，一般情况下不用考虑超限问题，用得最多。比如商品编号。<br>（5）BIGINT ：只有当你处理特别巨大的整数时才会用到。比如双十一的交易量、大型门户网站点击量、证券公司衍生产品持仓等。</p><h2 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h2><h3 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">show databases;</code></pre><h3 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">use database_name;set names utf8;</code></pre><h4 id="查看表"><a href="#查看表" class="headerlink" title="查看表"></a>查看表</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">show tables;</code></pre><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE TABLE table_name(column_name1 data_type(size),column_name2 data_type(size),column_name3 data_type(size));CREATE TABLE Persons(PersonID int,LastName varchar(255),FirstName varchar(255),Address varchar(255),City varchar(255));</code></pre><p>可使用 INSERT INTO 语句向空表写入数据。</p><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>在创建表的时候用于规定数据规则，比如NOT NULL</p><p>在 SQL 中，我们有如下约束：</p><h4 id="NOT-NULL"><a href="#NOT-NULL" class="headerlink" title="NOT NULL"></a>NOT NULL</h4><ul><li>指示某列不能存储 NULL 值。在默认的情况下，表的列接受 NULL 值。</li></ul><h4 id="UNIQUE"><a href="#UNIQUE" class="headerlink" title="UNIQUE"></a>UNIQUE</h4><ul><li><p>保证某列的每行必须有唯一的值。比如ID等值需要唯一性</p></li><li><p>语法：</p></li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">/*MySQL*/CREATE TABLE Persons(P_Id int NOT NULL,Name varchar(255) NOT NULL,UNIQUE (P_Id));/*SQL Server / Oracle / MS Access*/CREATE TABLE Persons(P_Id int NOT NULL UNIQUE,Name varchar(255) NOT NULL,);</code></pre><ul><li>定义多个列的 UNIQUE 约束：</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">/*MySQL / SQL Server / Oracle / MS Access：*/CREATE TABLE Persons(P_Id int NOT NULL,Name varchar(255) NOT NULL,CONSTRAINT uc_PersonID UNIQUE (P_Id,LastName));</code></pre><ul><li>当表已被创建时，如需在 “P_Id” 列创建 UNIQUE 约束，请使用下面的 SQL：</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">ALTER TABLE Persons ADD UNIQUE (P_Id);</code></pre><ul><li>定义多个列的 UNIQUE 约束:</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">ALTER TABLE Persons ADD CONSTRAINT uc_PersonID UNIQUE (P_Id,LastName);</code></pre><ul><li><strong>撤销UNIQUE约束</strong></li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">/*MySQL*/ALTER TABLE PersonsDROP INDEX uc_PersonID/*SQL Server / Oracle / MS Access*/ALTER TABLE PersonsDROP CONSTRAINT uc_PersonID</code></pre><h4 id="PRIMARY-KEY"><a href="#PRIMARY-KEY" class="headerlink" title="PRIMARY KEY"></a>PRIMARY KEY</h4><ul><li><p>NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。</p></li><li><p><strong>主键必须包含唯一的值。</strong></p><p>  <strong>主键列不能包含 NULL 值。</strong></p><p>  <strong>每个表都应该有一个主键</strong>，<strong>并且每个表只能有一个主键</strong>。</p>  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">/*MySQL*/CREATE TABLE Persons(P_Id int NOT NULL,Name varchar(255) NOT NULL,PRIMARY KEY (P_Id))/*SQL Server / Oracle / MS Access：*/CREATE TABLE Persons(P_Id int NOT NULL PRIMARY KEY,Name varchar(255) NOT NULL,)</code></pre></li><li><p><strong>ALTER TABLE 时的 SQL PRIMARY KEY 约束</strong></p><p>  当表已被创建时，如需在 “P_Id” 列创建 PRIMARY KEY 约束，请使用下面的 SQL：</p>  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">/*MySQL / SQL Server / Oracle / MS Access*/ALTER TABLE Persons ADD PRIMARY KEY (P_Id)</code></pre><p>  如需命名 PRIMARY KEY 约束，并定义多个列的 PRIMARY KEY 约束，请使用下面的 SQL 语法：</p>  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">/*MySQL / SQL Server / Oracle / MS Access*/ALTER TABLE Persons ADD CONSTRAINT pk_PersonID PRIMARY KEY (P_Id,LastName)</code></pre><p>  <strong>注释：</strong>如果您使用 ALTER TABLE 语句添加主键，必须把主键列声明为不包含 NULL 值（在表首次创建时）。</p><hr><p>  <strong>撤销 PRIMARY KEY 约束</strong></p><p>  如需撤销 PRIMARY KEY 约束，请使用下面的 SQL：</p>  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">/*MySQL*/ALTER TABLE Persons DROP PRIMARY KEY/*SQL Server / Oracle / MS Access*/ALTER TABLE Persons DROP CONSTRAINT pk_PersonIDALTER TABLE Persons DROP CONSTRAINT P_Id</code></pre></li></ul><h4 id="FOREIGN-KEY"><a href="#FOREIGN-KEY" class="headerlink" title="FOREIGN KEY"></a>FOREIGN KEY</h4><ul><li><p>一个表中的 FOREIGN KEY 指向另一个表中的 UNIQUE KEY(唯一约束的键)。保证一个表中的数据匹配另一个表中的值的参照完整性。</p></li><li><p>外键的解释：一个表中的某一列为外键，与另一个表的唯一约束键（UNIQUE KEY）</p></li><li><p>FOREIGN KEY 约束用于预防破坏表之间连接的行为。</p><p>  FOREIGN KEY 约束也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一</p>  <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">/*MySQL*/CREATE TABLE Orders(O_Id int NOT NULL,OrderNo int NOT NULL,P_Id int,PRIMARY KEY (O_Id),FOREIGN KEY (P_Id) REFERENCES Persons(P_Id))/*SQL Server / Oracle / MS Access*/CREATE TABLE Orders(O_Id int NOT NULL PRIMARY KEY,OrderNo int NOT NULL,P_Id int FOREIGN KEY REFERENCES Persons(P_Id))</code></pre></li></ul><h4 id="CHECK"><a href="#CHECK" class="headerlink" title="CHECK"></a>CHECK</h4><p>保证列中的值符合指定的条件。</p><h4 id="DEFAULT"><a href="#DEFAULT" class="headerlink" title="DEFAULT"></a>DEFAULT</h4><p>规定没有给列赋值时的默认值。</p><h4 id="AUTO-INCREMENT"><a href="#AUTO-INCREMENT" class="headerlink" title="AUTO INCREMENT"></a>AUTO INCREMENT</h4><p>自增</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE TABLE Persons(ID int NOT NULL AUTO_INCREMENT,PRIMARY KEY (ID))</code></pre><p>可使id自增</p><p>修改起始值</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">ALTER TABLE Persons AUTO_INCREMENT=100</code></pre><h2 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h2><h3 id="修改字段"><a href="#修改字段" class="headerlink" title="修改字段"></a>修改字段</h3><p>请注意，修改字段可能会影响到已经存在的应用程序或查询，因此应该在进行此操作之前备份数据表。</p><h4 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h4><pre class="line-numbers language-none"><code class="language-none">ALTER TABLE table_name ADD column_name data_type;</code></pre><p>新增指定位置</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">ALTER TABLE table_name ADD column_name data_type AFTER existing_column;</code></pre><h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">ALTER TABLE table_name MODIFY column_name new_data_type;</code></pre><p>其中，<code>table_name</code>是要修改的表名，<code>column_name</code>是要修改的字段名，<code>new_data_type</code>是新的数据类型。</p><h4 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">ALTER TABLE table_name RENAME COLUMN old_column_name TO new_column_name;</code></pre><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">ALTER TABLE table_name DROP column_name;</code></pre><p>其中table_name是要修改的表名，column_name是要删除的字段名。</p><h2 id="查看表结构"><a href="#查看表结构" class="headerlink" title="查看表结构"></a>查看表结构</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">describe table_name;desc table_name;#或show create table SALGRADE;</code></pre><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>当数据量大的时候，数据量会刷屏，使用pager less 可以切换less模式，除了pager less，还有pager more，pager awk、pager wc -l（统计行数）等，直接使用查询，可生效</p><p>语法：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT [字段],[字段] FROM [表名];SELECT * FROM student;</code></pre><h3 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h3><p>SELECT DISTINST</p><p>返回唯一不同的值，可理解为不重复</p><p>与select使用方法一样，DISTINCT 关键字只能在 SELECT 语句中使用。</p><p>如果 DISTINCT 关键字后有多个字段，则会对多个字段进行组合去重，也就是说，只有多个字段组合起来完全是一样的情况下才会被去重。<strong>就是逻辑与的关系，两个字段都要一样才能被去除</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT DISTINCT name,age FROM student;</code></pre><h3 id="LIMIT"><a href="#LIMIT" class="headerlink" title="LIMIT"></a>LIMIT</h3><p>用于返回规定要返回记录的数目</p><p><strong>注意:。MySQL 支持 LIMIT 语句来选取指定的条数数据， Oracle 可以使用 ROWNUM 来选取。</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT [column_name] FROM [table_name] LIMIT [number];SELECT * FROM websites LIMIT 2;输出前两个</code></pre><p>指定初始位置</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT * FROM websites LIMIT 2,6;#指定第三个开始的后六个#LIMIT 后的两个参数必须都是正整数。</code></pre><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><ul><li><code>%</code> 类似于<code>*</code></li><li><code>_</code> 下划线表示一个字符；</li><li><code>M%</code> : 为能配符，正则表达式，表示的意思为模糊查询信息为 M 开头的。</li><li><code>%M%</code> : 表示查询包含M的所有内容。</li><li><code>%M_</code> : 表示查询以M在倒数第二位的所有内容。</li></ul><p>SQL [charlist]</p><p>MySQL中使用 <strong>REGEXP</strong> 或 <strong>NOT REGEXP</strong> 运算符 (或 <strong>RLIKE</strong> 和 <strong>NOT RLIKE</strong>) 来操作正则表达式</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT * FROM Websites WHERE name REGEXP '^[GFs]';</code></pre><p>正则表达式不区分大小写，如果需要区分，则加上 BINARY 关键字 </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT * FROM table WHERE name REGEXP (BINARY)  'jayce';</code></pre><p>常规的三个：（如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。）</p><p><code>^</code>    匹配输入字符串的开始位置。</p><p><code>$</code>    匹配输入字符串的结束位置。</p><p><code>*</code>    匹配 0 次或多次。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 查找name字段中以'st'为开头的所有数据：SELECT name FROM person_tbl WHERE name REGEXP '^st';-- 查找name字段中以'ok'为结尾的所有数据：SELECT name FROM person_tbl WHERE name REGEXP 'ok$';-- 查找name字段中包含'mar'字符串的所有数据：SELECT name FROM person_tbl WHERE name REGEXP 'mar';-- 查找name字段中以'mar' 结尾并以任何前缀开头SELECT name FROM person_tbl WHERE name REGEXP '.*mar';</code></pre><p>星号可用于与字符匹配 0 次或多次。例如，<code>REGEXP '.*abc'</code> 匹配的字符串以 abc 结尾并以任何前缀开头。因此，aabc、xyzabc 和 abc 匹配，但 bc 和 abcc 则不匹配。</p><p>.    匹配除 “\n” 之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用像 ‘[.\n]’ 的模式</p><p>例如：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT name FROM person_tbl WHERE name REGEXP '.*mar';SELECT name FROM person_tbl WHERE name REGEXP '[*mar]';</code></pre><p>但是不可以写成：<code>'*mar*'</code></p><p><code>+</code>    匹配前面的子表达式<strong>一次或多次</strong>。</p><blockquote><p>加号可用于与字符匹配 1 次或多次。例如，<code>'bre+'</code> 匹配 bre 和 bree，但不匹配 br。</p></blockquote><p><img src="https://jaycehe.oss-cn-hangzhou.aliyuncs.com/markdown/202203281709030.png" alt="image-20220328170923052"></p><p>意思就是刚好匹配还不行，必须前面多一个</p><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>*</td><td>匹配它前面的零个或多个子表达式，0个或多个匹配，效果与{0,}—致</td></tr><tr><td>+</td><td>匹配它前面的一个或多个子表达式，1个或多个匹配，效果与{1,}一致</td></tr><tr><td>?</td><td>匹配它前面的零个或一个子表达式，1个或0匹配，效果与{0,1}一致</td></tr><tr><td>{n}</td><td>等于n个匹配数目</td></tr><tr><td>{n,}</td><td>大于等于n个匹配</td></tr><tr><td>{n,m}</td><td>大于等于n小于等于m个, m&lt;255</td></tr></tbody></table><p><code>[] </code>字符集合。匹配所包含的任意一个字符</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT * FROM runoob_test_tbl WHERE runoob_author REGEXP '[OB]';</code></pre><p><img src="https://jaycehe.oss-cn-hangzhou.aliyuncs.com/markdown/202203281650265.png" alt="image-20220328165035427"></p><p><code>[^...] </code>  负值字符集合。匹配未包含的任意字符。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT * FROM runoob_test_tbl WHERE runoob_author REGEXP '[^RUNOOB]';</code></pre><p>结果：</p><p><img src="https://jaycehe.oss-cn-hangzhou.aliyuncs.com/markdown/202203281656914.png" alt="image-20220328165604954"></p><p>结果发现RUNOOB并没有出现，原因是<code>[^RUNOOB]</code>过滤掉了<code>RUNOOB</code></p><p><code>p1|p2|p3</code>    匹配 p1 或 p2 或 p3。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。</p><table><thead><tr><th>模式</th><th>描述（具体匹配什么）</th></tr></thead><tbody><tr><td>.</td><td>匹配除 “\n” 之外的任何单个字符。</td></tr><tr><td>[abc]</td><td>匹配方括号之间列出的任何字符。</td></tr><tr><td>[^abc]</td><td>匹配方括号之间未列出的任何字符。</td></tr><tr><td>[A-Z]</td><td>匹配任何大写字母。</td></tr><tr><td>[a-z]</td><td>匹配任何小写字母。</td></tr><tr><td>[0-9]</td><td>匹配从0到9的任何数字。</td></tr><tr><td>[[:&lt;:]]</td><td>匹配单词的开头。</td></tr><tr><td>[[:&gt;:]]</td><td>匹配单词的结尾。</td></tr><tr><td>[:class:]</td><td>匹配字符类，即[：alpha：]匹配字母，[：space：]匹配空格，[：punct：]匹</td></tr><tr><td>配标点符号</td><td>，[：upper：] 匹配上层字母。</td></tr></tbody></table><h4 id="正则表达式测试"><a href="#正则表达式测试" class="headerlink" title="正则表达式测试"></a>正则表达式测试</h4><p>可以在不使用数据库表的情况下用 SELECT 语句来测试正则表达式，REGEXP 检查总是<strong>返回0（没有匹配）或1（匹配）</strong>。可以用带文字串的 REGEXP 来测试表达式，并试验它们。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT 'Hern' REGEXP '[0-9]';</code></pre><p><img src="https://jaycehe.oss-cn-hangzhou.aliyuncs.com/markdown/202203281640805.png" alt="image-20220328164007959"></p><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><h4 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a>WHERE</h4><p>用于提取满足条件的记录</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT [字段],[字段] FROM [表名] WHERE [字段] operator value;</code></pre><p>其中文本字段需要使用单引号</p><p>但where不一定非要运算符</p><p><code>where 0</code> 会返回一个空值</p><p><code>where 1</code> 相当于没有这句，因为每一行记录都返回true</p><h4 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h4><p>HAVING 关键字和 WHERE 关键字都可以用来过滤数据，且 HAVING 支持 WHERE 关键字中所有的操作符和语法。</p><p><strong>区别</strong>，where是挑选符合条件的查询，having是先全查出来再过滤。</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h4><p><code>+</code> <code>-</code> <code>*</code> <code>/</code> <code>div</code> <code>mod</code> <code>%</code>取余</p><p>当数值与字符串加时，会转换字符串为数值，转不了的转成0</p><p>100 + ‘1’ =101  100 + ‘a’ =100</p><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><table><thead><tr><th align="left">运算符</th><th align="center">描述</th><th>语法</th></tr></thead><tbody><tr><td align="left">=</td><td align="center">等于</td><td></td></tr><tr><td align="left">&lt;=&gt;</td><td align="center">安全等于，可以判断null</td><td></td></tr><tr><td align="left">&lt;&gt;</td><td align="center">不等于。<strong>注释：</strong>在 SQL 的一些版本中，该操作符可被写成 !=</td><td></td></tr><tr><td align="left">&gt;</td><td align="center">大于</td><td></td></tr><tr><td align="left">&lt;</td><td align="center">小于</td><td></td></tr><tr><td align="left">&gt;=</td><td align="center">大于等于</td><td></td></tr><tr><td align="left">&lt;=</td><td align="center">小于等于</td><td></td></tr><tr><td align="left">BETWEEN</td><td align="center">在某个范围内</td><td>where [字段] between value1 and value2;</td></tr><tr><td align="left">IN</td><td align="center">指定针对某个列的多个可能值</td><td>where sal in (5000,3000,1500);</td></tr><tr><td align="left">AND</td><td align="center">与，同时满足两个条件</td><td>where sal &gt; 2000 and sal &lt; 3000;</td></tr><tr><td align="left">OR</td><td align="center">或，满足其中一个条件的值</td><td></td></tr><tr><td align="left">NOT</td><td align="center">非 满足不包含该条件的值</td><td>where not sal &gt; 1500;  ==  sal&gt;=1500</td></tr><tr><td align="left">is null</td><td align="center">查询空值</td><td></td></tr><tr><td align="left">LIKE</td><td align="center">搜索某种模式</td><td>where ename like ‘M%’;内容有M的</td></tr></tbody></table><ul><li><strong>%</strong> 表示多个字值，</li><li><strong>_</strong>  表示一个字符；</li><li><strong>M%</strong> : 为能配符，正则表达式，表示的意思为模糊查询信息为 M 开头的。</li><li><strong>%M%</strong> : 表示查询包含M的所有内容。</li><li><strong>%M_</strong> : 表示查询以M在倒数第二位的所有内容。</li></ul><p>只要null参与，结果就为null</p><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>逻辑运算可以集合起来</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT * FROM Websites WHERE alexa &gt; 15 AND (country='CN' OR country='USA');</code></pre><p>逻辑运算的优先级：</p><blockquote><p>()    not        and         or</p></blockquote><p>XOR：记录满足其中一个条件，并且不满足另一个条件时，才会被查询出来</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>ORDER BY </p><p>语法：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT * FROM Websites ORDER BY alexa;</code></pre><p>默认按照升序排列（ASC）</p><p>降序：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT * FROM Websites ORDER BY alexa DESC;</code></pre><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>SQL </p><p>将表名称或列名称指定别名，创建别名让列名称可读性更强</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">SELECT column_name AS alias_name FROM table_name;SELECT column_name FROM table_name AS alias_name;</code></pre><p>别名有三种方式，直接写、as、<strong>双引号（不要写单引号）</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT column_name  alias_name FROM table_name;SELECT column_name AS alias_name FROM table_name;SELECT column_name   "alias name" FROM table_name;</code></pre><p>将多列结合一起：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT name, CONCAT(url, ', ', alexa, ', ', country) AS site_info FROM websites;</code></pre><p>对表使用别名：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT w.name FROM websites as w WHERE w.name='Google';</code></pre><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT w.name, w.url, a.count, a.date FROM Websites AS w, access_log AS a WHERE a.site_id=w.id and w.name="菜鸟教程";</code></pre><p>在下面的情况下，使用别名很有用：</p><ul><li>在查询中涉及超过一个表</li><li>在查询中使用了函数</li><li>列名称很长或者可读性差</li><li>需要把两个列或者多个列结合在一起</li></ul><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><h4 id="group-by"><a href="#group-by" class="headerlink" title="group by"></a>group by</h4><p>多个字段分组时，先按照字段顺序依次分组，如果前一个字段有重复，才会进行后续分组</p><h4 id="GROUP-CONCAT"><a href="#GROUP-CONCAT" class="headerlink" title="GROUP CONCAT"></a>GROUP CONCAT</h4><p>GROUP_CONCAT() 函数会把每个分组的字段值都显示出来。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT `sex`, GROUP_CONCAT(name) FROM tb_students_info GROUP BY sex;</code></pre><blockquote><p>女   Henry,Jim,John,Thomas,Tom<br>男   Dany,Green,Jane,Lily,Susan</p></blockquote><p>GROUP BY 关键字经常和聚合函数一起使用。</p><p>聚合函数包括 COUNT()，SUM()，AVG()，MAX() 和 MIN()。</p><h4 id="WITH-ROLLUP"><a href="#WITH-ROLLUP" class="headerlink" title="WITH ROLLUP"></a>WITH ROLLUP</h4><p>WITH POLLUP 关键字用来在所有记录的最后加上一条记录，这条记录是上面所有记录的总和，即统计记录数量。</p><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>（JOIN）</p><p>sql join用于将两个表结合起来</p><p>下图展示了 LEFT JOIN、RIGHT JOIN、INNER JOIN、OUTER JOIN 相关的 7 种用法。</p><p><a href="https://www.runoob.com/wp-content/uploads/2019/01/sql-join.png"><img src="https://jaycehe.oss-cn-hangzhou.aliyuncs.com/markdown/202109171525432.png" alt="img"></a></p><h4 id="INNER-JOIN"><a href="#INNER-JOIN" class="headerlink" title="INNER JOIN"></a>INNER JOIN</h4><p>在表中存在至少一个匹配</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT column_name FROM table1 INNER JOIN table2 ON table1.column_name=table2.column_name;SELECT column_name FROM table1 JOIN table2 ON table1.column_name=table2.column_name;</code></pre><p>INNER JOIN 与JOIN相同</p><p><img src="https://jaycehe.oss-cn-hangzhou.aliyuncs.com/markdown/202109171525690.png" alt="image-20210723094810785"></p><h4 id="LEFT-JOIN"><a href="#LEFT-JOIN" class="headerlink" title="LEFT JOIN"></a>LEFT JOIN</h4><p>从左表返回所有的行，如果右表没有匹配，结果为NULL</p><p><img src="https://jaycehe.oss-cn-hangzhou.aliyuncs.com/markdown/202109171525903.png" alt="image-20210725182757047"></p><h4 id="RIGHT-JOIN"><a href="#RIGHT-JOIN" class="headerlink" title="RIGHT JOIN"></a>RIGHT JOIN</h4><p>从右表返回所有的行，如果左表没有匹配，结果为NULL</p><h4 id="FULL-OUTER-JOIN"><a href="#FULL-OUTER-JOIN" class="headerlink" title="FULL OUTER JOIN"></a>FULL OUTER JOIN</h4><p>只要左右表中存在一个表匹配，则返回行</p><p>FULL OUTER JOIN 关键字结合了 LEFT JOIN 和 RIGHT JOIN 的结果。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT column_name(s) FROM table1 FULL OUTER JOIN table2 ON table1.column_name=table2.column_name</code></pre><h4 id="SQL-UNION"><a href="#SQL-UNION" class="headerlink" title="SQL UNION"></a>SQL UNION</h4><p><code>UNION</code>操作符<strong>合并</strong>两个以上<code>SELECT</code>语句</p><p>请注意，UNION 内部的每个 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 SELECT语句中的列的顺序必须相同。</p><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT name FROM tb_students_info WHERE course_id IN (SELECT id FROM tb_course WHERE course_name = 'Java');</code></pre><p>需要注意的是，只出现在子查询中而没有出现在父查询中的表不能包含在输出列中。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">#错误SELECT * FROM (SELECT * FROM result)#zSELECT * FROM (SELECT * FROM result) AS Temp;</code></pre><h3 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a>NULL</h3><ul><li><strong>IS NULL:</strong> 当列的值是 NULL,此运算符返回 true。</li><li><strong>IS NOT NULL:</strong> 当列的值不为 NULL, 运算符返回 true</li><li><strong>&lt;=&gt;:</strong> 比较操作符（不同于 = 运算符），当比较的的两个值相等或者都为 NULL 时返回 true。<strong>只比较NULL</strong></li></ul><p>**不能使用 = NULL 或 != NULL 在列中查找 NULL 值 **</p><p><strong>注意：</strong></p><pre class="line-numbers language-none"><code class="language-none">select * , columnName1+ifnull(columnName2,0) from tableName;</code></pre><p>columnName1，columnName2 为 int 型，当 columnName2 中，有值为 null 时，columnName1+columnName2=null，</p><h4 id="空值参与运算"><a href="#空值参与运算" class="headerlink" title="空值参与运算"></a>空值参与运算</h4><p>空值参与运算，结果为空，可使用ifnull函数解决 </p><pre class="line-numbers language-none"><code class="language-none">ifnull(columnName2,0)</code></pre><p>把 columnName2 中 null 值转为 0。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT 1 + IFNULL(LOSAL,0)  FROM  SALGRADE;</code></pre><h3 id="着重号"><a href="#着重号" class="headerlink" title="着重号"></a>着重号</h3><p>在表名，字段等与数据库保留字冲突时使用</p><pre class="line-numbers language-none"><code class="language-none">``</code></pre><p>查看所有表大小和记录</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT concat_ws('.',a.table_schema ,a.table_name),CONCAT(ROUND(table_rows)) AS 'Number of Rows',CONCAT(ROUND(data_length/(1024*1024),4),',') AS 'data_size',CONCAT(ROUND(index_length/(1024*1024),4),'M') AS 'index_size',CONCAT(ROUND((data_length+index_length)/(1024*1024),4),'M') AS'Total'FROMinformation_schema. TABLES a    WHEREa.table_schema = 'j'  order by CAST(Total AS SIGNED);</code></pre><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>INSERT INTO </p><p>第一种形式，无需指定列名，只需提供被插值</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">INSERT INTO Websites (name, url, alexa, country) VALUES ('百度','https://www.baidu.com/','4','CN');</code></pre><p><strong>如果不指定列名，需要将values全部按顺序列出</strong></p><p>insert into select 和select into from </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">insert into scorebak select * from socre where neza='neza'   --插入一行,要求表scorebak 必须存在select *  into scorebak from score  where neza='neza'  --也是插入一行,要求表scorebak 不存在</code></pre><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>UPDATE </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">UPDATE [table_name] SET column1=value1,column2=value2,... WHERE some_column=some_value;</code></pre><h3 id="Update-警告！"><a href="#Update-警告！" class="headerlink" title="Update 警告！"></a>Update 警告！</h3><p>在更新记录时要格外小心！在上面的实例中，如果我们省略了 WHERE 子句，如下所示：</p><pre class="line-numbers language-none"><code class="language-none">UPDATE WebsitesSET alexa='5000', country='USA'</code></pre><p>执行以上代码会将 Websites 表中所有数据的 alexa 改为 5000，country 改为 USA。</p><p><strong>！！！！执行没有 WHERE 子句的 UPDATE 要慎重，再慎重。！！！！</strong></p><h2 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h2><p>DELETE </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">DELETE FROM [table_name] WHERE [some_column=some_value];</code></pre><p>删除行</p><h3 id="表复制"><a href="#表复制" class="headerlink" title="表复制"></a>表复制</h3><p>INSERT INTO SELECT</p><p>INSERT INTO SELECT 语句从一个表复制数据，然后把数据插入到一个已存在的表中。目标表中任何已存在的行都不会受影响。</p><p>复制希望的列插入到另一个已存在的表中</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">INSERT INTO table2 (column_name(s)) SELECT column_name(s) FROM table1;INSERT INTO Websites (name, country) SELECT app_name, country FROM apps;</code></pre><h2 id="数据导入导出"><a href="#数据导入导出" class="headerlink" title="数据导入导出"></a>数据导入导出</h2><h3 id="mysqldump"><a href="#mysqldump" class="headerlink" title="mysqldump"></a>mysqldump</h3><table><thead><tr><th align="left">参数名</th><th align="left">缩写</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">–host</td><td align="left">-h</td><td align="left">服务器IP地址</td></tr><tr><td align="left">–port</td><td align="left">-P</td><td align="left">服务器端口号</td></tr><tr><td align="left">–user</td><td align="left">-u</td><td align="left">MySQL 用户名</td></tr><tr><td align="left">–pasword</td><td align="left">-p</td><td align="left">MySQL 密码</td></tr><tr><td align="left">–databases</td><td align="left"></td><td align="left">指定要备份的数据库</td></tr><tr><td align="left">–all-databases</td><td align="left"></td><td align="left">备份mysql服务器上的所有数据库</td></tr><tr><td align="left">–compact</td><td align="left"></td><td align="left">压缩模式，产生更少的输出</td></tr><tr><td align="left">–comments</td><td align="left"></td><td align="left">添加注释信息</td></tr><tr><td align="left">–complete-insert</td><td align="left"></td><td align="left">输出完成的插入语句</td></tr><tr><td align="left">–lock-tables</td><td align="left"></td><td align="left">备份前，锁定所有数据库表</td></tr><tr><td align="left">–no-create-db/–no-create-info</td><td align="left"></td><td align="left">禁止生成创建数据库语句</td></tr><tr><td align="left">–force</td><td align="left"></td><td align="left">当出现错误时仍然继续备份操作</td></tr><tr><td align="left">–default-character-set</td><td align="left"></td><td align="left">指定默认字符集</td></tr><tr><td align="left">–add-locks</td><td align="left"></td><td align="left">备份数据库表时锁定数据库表</td></tr><tr><td align="left">–single-transaction</td><td align="left">必加</td><td align="left">备份时不影响数据库运行</td></tr></tbody></table><p>备份所有数据库：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysqldump -uroot -p --all-databases &gt;/all.db</code></pre><h3 id="outfile-amp-infile"><a href="#outfile-amp-infile" class="headerlink" title="outfile &amp; infile"></a>outfile &amp; infile</h3><h4 id="outfile"><a href="#outfile" class="headerlink" title="outfile"></a>outfile</h4><p>语法：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select * from table into outfile '/dic/dic/file' fields terminated by '|'</code></pre><p><code>fields terminated by '|'</code>代表以竖线分隔，默认为空格分隔</p><p>注意，不是这里涉及到输出限制，查询secure_file_priv参数，看看mysql可以输出到哪里</p><blockquote><p>ERROR 1290 (HY000): The MySQL server is running with the –secure-file-priv option so it cannot execute this statement</p></blockquote><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">show global variables like '%secure_file_priv%';</code></pre><p>secure_file_priv 为 NULL 时，表示限制mysqld不允许导入或导出。</p><p>secure_file_priv 为 /tmp 时，表示限制mysqld只能在/tmp目录中执行导入导出，其他目录不能执行。</p><p>secure_file_priv 没有值时，表示不限制mysqld在任意目录的导入导出。</p><p>secure_file_priv 参数是只读参数，不能使用set global命令修改。</p><h4 id="infile"><a href="#infile" class="headerlink" title="infile"></a>infile</h4><p>语法：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">load data infile '/dic/dic/file' into table database_name.tablename fields terminated by '|'</code></pre><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图是可视化的表，视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。</p><h3 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE VIEW view_name AS SELECT column_name(s) FROM table_name WHERE condition</code></pre><p>例子：</p><p>创建关于销售员的职工表</p><p>总职工：</p><p><img src="https://jaycehe.oss-cn-hangzhou.aliyuncs.com/markdown/202204121522617.png" alt="image-20220412152203540"></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE  VIEW sell AS  SELECT * FROM `EMP` WHERE JOB="销售员";</code></pre><p><img src="https://jaycehe.oss-cn-hangzhou.aliyuncs.com/markdown/202204121522615.png" alt="image-20220412152224544"></p><h3 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h3><pre class="line-numbers language-none"><code class="language-none">CREATE OR REPLACE VIEW view_name ASSELECT column_name(s)FROM table_nameWHERE condition</code></pre><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引是一张表，该表保存了主键与索引字段，并指向实体表的记录。类似于字典的目录。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li><p>单列索引</p><ul><li><p>普通索引</p><p>MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了查询数据更快一 点。</p></li><li><p>唯一索引</p><p>索引列中的值必须是唯一的，但是允许为空值。</p></li><li><p>主键索引</p><p>是一种特殊的唯一索引，不允许有空值。（主键约束，就是一个主键索引）。</p></li></ul></li><li><p>组合索引</p><p>在表中的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时遵循最左前缀集合。</p></li><li><p>全文索引</p><p>只有在<strong>MyISAM</strong>引擎上才能使用，只能在CHAR,VARCHAR,TEXT类型字段上使用全文索引，介绍了要求，说说什么是全文索引，就是在一堆文字中，通过其中的某个关键字等，就能找到该字段所属的记录行。</p></li></ul><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><h4 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h4><ol><li><p>直接创建</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE INDEX indexName ON table_name (column_name)</code></pre></li><li><p>修改表结构</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">ALTER table tableName ADD INDEX indexName(columnName)</code></pre></li><li><p>创建表的时候直接指定</p><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE mytable(  ID INT NOT NULL,   username VARCHAR(16) NOT NULL,  INDEX [indexName] (username(length))  );  </code></pre></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用hexo框架搭建个人博客</title>
      <link href="//post/hexo-install.html"/>
      <url>//post/hexo-install.html</url>
      
        <content type="html"><![CDATA[<p>使用hexo框架搭建个人博客已有2个多月，是时候写一篇部署步骤以及踩坑总结了<br>为什么使用hexo</p><h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><p>hexo可以直接通过npm进行安装，windows同理</p><pre class="line-numbers language-none"><code class="language-none">npm install -g hexo-cli</code></pre><p><img src="https://oss.jayce.icu/image-20220427224941463.png" alt="image-20220427224941463"></p><p>出现此报错命令前加sudo</p><p>安装成功后，可以直接新建一个项目</p><p><img src="https://oss.jayce.icu/image-20220427225043033.png" alt="image-20220427225043033"></p><p>新建一个项目，并初始化，其中名字自定义    </p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">hexo init blog_name</code></pre><p>此时hexo会从github将框架拉到本地的项目名称文件夹下</p><p><img src="https://oss.jayce.icu/image-20220427225351741.png" alt="image-20220427225351741"></p><p><img src="https://oss.jayce.icu/image-20220427225423970.png" alt="image-20220427225423970"></p><p>使用ide打开，我使用的是webstorm，根据个人喜好即可</p><p>打开项目后，使用``npm install` 将package.json 中的包下载下来</p><p><img src="https://oss.jayce.icu/image-20220427225734227.png" alt="image-20220427225734227"></p><p>此时这个最简单的项目基本框架就算有了，生成一下静态文件，用浏览器看看吧</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">hexo generate  #生成静态文件   简写hexo ghexo server    #启动服务器    简写hexo s</code></pre><p><img src="https://oss.jayce.icu/image-20220427230214814.png" alt="image-20220427230214814"></p><p>打开<a href="http://localhost:4000/">http://localhost:4000/</a></p><p>即可进入欢迎界面：</p><p><img src="https://oss.jayce.icu/image-20220427230335376.png" alt="image-20220427230335376"></p><p>接着我们在github上新建一个仓库，仓库的名字必须是<code>用户名.github.io</code>格式，比如<img src="https://oss.jayce.icu/image-20220427231524340.png" alt="image-20220427231524340"></p><p>将静态网页部署在此仓库即可通过上面的域名进行访问。如果觉得github的网络不好也可以使用国内的gitee，操作方法一致。</p><p>接着安装deploy-git</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">npm install hexo-deployer-git --save</code></pre><p>在配置文件<code>_config.yml</code>中添加刚才的仓库信息，注意这里的config是根目录下的，而不是主题配置文件</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">deploy:  type: git  repo: git@github.com:HeJayce/HeJayce.github.io.git  branch: master</code></pre><p>这里的repo是你仓库的git地址，branch默认master，如需要分支，可改为相应分支</p><p>使用<code>hexo d</code>即可将项目push到github仓库去</p><h2 id="模板选择"><a href="#模板选择" class="headerlink" title="模板选择"></a>模板选择</h2><p>在github中有许多开源的模板（主题）可供大家选择，大家也可自行百度，选择自己喜欢的模板。我选择的是<a href="https://github.com/blinkfox/hexo-theme-matery">mater模板</a>，不同的模板有不同的配置，选择的时候需要仔细阅读开发者提供的使用说明</p><p><img src="https://oss.jayce.icu/image-20220427230711782.png" alt="image-20220427230711782"></p><p>将喜欢的模板下载下来后，放入themes 文件夹下，直接将整个文件夹放入就好</p><p><img src="https://oss.jayce.icu/image-20220427231227399.png" alt="image-20220427231227399"></p><p>接着在<code>_config.yml</code>中找到theme ，将theme的参数改为模板名称，注意模板名称为文件夹名称，改完后重新生成文件并启动服务：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">hexo clhexo ghexo s</code></pre><p><img src="https://oss.jayce.icu/image-20220501161105372.png" alt="image-20220501161105372"></p><p>此时再打开localhost 4000端口，看看主题有没有配置成功</p><p><img src="https://oss.jayce.icu/image-20220501161543955-20220501171717958.png" alt="image-20220501161217056"></p><h2 id="第一篇博客"><a href="#第一篇博客" class="headerlink" title="第一篇博客"></a>第一篇博客</h2><p>框架打好后，试一下写第一篇博客吧，新建一个post，hexo会自动生成一个md文件，需要熟悉markdown这种文件格式</p><pre class="line-numbers language-none"><code class="language-none">hexo new post [blog_name]</code></pre><p><img src="https://oss.jayce.icu/image-20220501161543955-20220501171717958.png" alt="image-20220501161543955"></p><p><img src="https://oss.jayce.icu/image-20220501162931117-20220501171718190.png" alt="image-20220501162931117"></p><p>此时就可以编写了，随便写点内容，看看有没有发布吧。编写好后按照上面的方法生成静态文件，再次打开localhost 4000 ，看看有无文章</p><p><img src="https://oss.jayce.icu/image-20220501163000610.png" alt="image-20220501163000610"> <img src="https://oss.jayce.icu/image-20220501163019437.png" alt="image-20220501163019437"></p><h2 id="服务器部署"><a href="#服务器部署" class="headerlink" title="服务器部署"></a>服务器部署</h2><p>由于是静态网页，服务器部署起来非常简单，如果自己有服务器可以进行服务器部署，后续可增加可玩性。</p><p>静态网页通过nginx即可完成，没有nginx的通过yum安装即可</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">yum install epel-releaseyum install -y nginx</code></pre><p>将github上发布的代码克隆到服务器即可</p><p><img src="https://oss.jayce.icu/markdown/202204281451049.png" alt="image-20220428145145675"></p><p>在nginx配置文件中修改成下面的配置，root填写项目文件夹地址</p><pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx">server {        listen       80;        server_name  localhost;        location / {            root  /root/HeJayce.github.io;            index index.html;        }}</code></pre><p>改好别忘了重载nginx配置</p><p>这时打开浏览器访问IP:80 或域名就会打开index.html，即你的主页</p><h2 id="https"><a href="#https" class="headerlink" title="https"></a>https</h2><p>设置https可以到阿里云申请免费的证书，每人有20个额度</p><p><img src="https://oss.jayce.icu/markdown/202204261132101.png" alt="image-20220426113211531"></p><p><img src="https://oss.jayce.icu/markdown/202204261133715.png" alt="image-20220426113304547"></p><p>购买完成后，进入ssl证书管理台，选择免费证书</p><p><img src="https://oss.jayce.icu/markdown/202204261134061.png" alt="image-20220426113400984"></p><p>点击创建证书，会在列表里新建一个待申请证书，点击右边证书申请，填写你的域名以及信息，CSR选择系统生成</p><p><img src="https://oss.jayce.icu/markdown/202204261137893.png" alt="image-20220426113751817"></p><p>注意你的域名需要添加到DNS解析当中</p><p>创建好证书后，将申请好的证书下载下来，使用nginx代理就选择nginx证书</p><p><img src="https://oss.jayce.icu/image-20220427223638482.png" alt="image-20220427223638482"></p><p>下载下来后是两个文件</p><p><img src="https://oss.jayce.icu/image-20220427223736666.png" alt="image-20220427223736666"></p><p>进入服务器，打开nginx的配置，添加以下内容：</p><pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx">server {        listen       443 ssl;        server_name  jayce.icu;        # ssl证书地址        ssl_certificate     /usr/local/nginx/cert/jayce.pem;  # pem文件的路径        ssl_certificate_key  /usr/local/nginx/cert/jayce.key; # key文件的路径        # ssl验证相关配置        ssl_session_timeout  5m;    #缓存有效期        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;    #加密算法        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;    #安全链接可选的加密协议        ssl_prefer_server_ciphers on;   #使用服务器端的首选算法        location / {            root /var/lib/jenkins/workspace/jayce_blog;            index index.html;        }}</code></pre><p>其中将刚才下载的两个文件放入服务器，将配置文件中两个文件的路径改为实际路径，注意pem和key文件的位置</p><p>server_name 填写你申请证书的地址</p><p>ssl相关配置可以不用管，复制即可</p><p>重载nginx，过几分钟后验证即可</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">nginx -s reload</code></pre><p>强制http转https:</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">server {    listen 80;    server_name  jayce.icu  www.jayce.icu;    return 301 https://jayce.icu$request_uri;}</code></pre><h2 id="个性化改装"><a href="#个性化改装" class="headerlink" title="个性化改装"></a>个性化改装</h2><p>我使用的是<a href="https://github.com/blinkfox/hexo-theme-matery">matert</a>主题，主要的配置方法都在他的主页中有讲解，但如果需要更换颜色，字体，以及更加复杂的需求时，就需要对代码进行修改，充分利用F12以及IDE全局搜索，快速定位到css，js文件，进行修改。</p><p>举个例子：</p><p>我想修改原来模板的导航栏渐变颜色</p><p><img src="https://oss.jayce.icu/image-20220501163715336.png" alt="image-20220501163715336"></p><p>打开F12，看哪个文件定义了标题栏的颜色</p><img src="https://oss.jayce.icu/image-20220501163956503.png" alt="image-20220501163956503" style="zoom: 200%;"><p>从开发者模式可得，<code>matery.css</code>下面的代码是修改背景渐变颜色的</p><p><img src="https://oss.jayce.icu/image-20220501164233110.png" alt="image-20220501164233110"></p><p>找到该文件，并自行修改</p><p><img src="https://oss.jayce.icu/image-20220501164407058.png" alt="image-20220501164407058"></p><p>再看看页面，颜色就变了</p><p><img src="https://oss.jayce.icu/image-20220501164451931.png" alt="image-20220501164451931"></p><h2 id="代码部署同步"><a href="#代码部署同步" class="headerlink" title="代码部署同步"></a>代码部署同步</h2><p>使用jenkins实现服务器与github代码同步，本地部署到github后，服务器会自动拉取最新的代码</p><p><a href="https://jayce.icu/post/jenkins-github.html">在服务器部署Jenkins同步github代码 | Jayce’s Blog</a></p><h2 id="git-分支"><a href="#git-分支" class="headerlink" title="git 分支"></a>git 分支</h2><p>有多个版本的需求，可在IDE中创建新的分支，一个是github.io的分支，一个是该项目的分支，并且在config中将master分支改为你创建的分支名</p><p><img src="https://oss.jayce.icu/image-20220501165147849.png" alt="image-20220501165147849"></p><p><img src="https://oss.jayce.icu/image-20220501165200028.png" alt="image-20220501165200028"></p><p><img src="https://oss.jayce.icu/image-20220501165230041.png" alt="image-20220501165230041"></p>]]></content>
      
      
      <categories>
          
          <category> 部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
            <tag> github </tag>
            
            <tag> 阿里云 </tag>
            
            <tag> https </tag>
            
            <tag> hexo </tag>
            
            <tag> 博客 </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器简单的监控脚本</title>
      <link href="//post/watchdog.html"/>
      <url>//post/watchdog.html</url>
      
        <content type="html"><![CDATA[<h2 id="服务器简单的监控脚本监控docker等进程"><a href="#服务器简单的监控脚本监控docker等进程" class="headerlink" title="服务器简单的监控脚本监控docker等进程"></a>服务器简单的监控脚本监控docker等进程</h2><p>脚本实现监控docker 运行的各个服务和其他重要程序，当某项服务挂了，可发邮件给管理者，并自动重启</p><h2 id="自动发送邮件"><a href="#自动发送邮件" class="headerlink" title="自动发送邮件"></a>自动发送邮件</h2><p>安装maix</p><p><img src="https://oss.jayce.icu/markdown/202204081115382.png" alt="image-20220408111516967"></p><p>关闭默认邮件服务器（centos7）</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">systemctl stop postfixsystemctl stop sendmail</code></pre><p>编辑配置文件  <code>/etc/mail.rc</code>，添加下面内容</p><pre class="line-numbers language-none"><code class="language-none">set from=notice@jayce.icuset smtp=smtps://smtp.exmail.qq.com:465set smtp-auth-user=notice@jayce.icuset smtp-auth-password=*******set smtp-auth=loginset ssl-verify=ignoreset nss-config-dir=/etc/pki/nssdb</code></pre><p>set from  发送邮件的邮箱<br>set smtp  邮箱的stmp服务器地址<br>set smtp-auth-user   登录名<br>set smtp-auth-password  登录名<br>set smtp-auth=login  登录验证<br>set ssl-verify=ignore  忽略ssl证书 <em>重要</em><br>set nss-config-dir=/etc/pki/nssdb  ssl证书目录</p><p>具体的邮箱服务器地址，端口，登录密码等以实际邮箱情况为准，有些密码需要授权</p><p>阿里云服务器为了防止垃圾短信，默认关闭25号端口，需要在安全组规则开通465端口</p><p>配置成功后测试一下：</p><p><img src="https://oss.jayce.icu/markdown/202204081327730.png" alt="image-20220408132759402"></p><p><img src="https://oss.jayce.icu/markdown/202204081328786.png" alt="image-20220408132818714"></p><h2 id="监控docker服务"><a href="#监控docker服务" class="headerlink" title="监控docker服务"></a>监控docker服务</h2><p>获取docker的状态</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">docker ps -a</code></pre><p><img src="https://oss.jayce.icu/markdown/202204081334165.png" alt="image-20220408133446902"></p><p>从status可知具体的状态，从此可进行判断进程状态，先来一个判断是否exit的</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">docker ps -a |grep Exited</code></pre><p><img src="https://oss.jayce.icu/markdown/202204081336789.png" alt="image-20220408133617687"></p><p>当此命令有返回时，即有服务退出了，利用此特性，可以将退出的进程发送邮件给管理者</p><p>取出状态为Exited的服务名：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker_images_status_exited=$(docker ps -a | grep Exited | awk '{print $NF}')</code></pre><p><img src="https://oss.jayce.icu/markdown/202204081340268.png" alt="image-20220408134055200"></p><p>发送邮件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">if [ "$docker_images_status_exited" ]; then  echo  $(date +%Y-%m-%-d-%H:%M:%S) $docker_images_status_exited $status &gt;&gt; /root/logs/docker.log  echo  $(date +%Y-%m-%-d-%H:%M:%S) $docker_images_status_exited $status | mailx -s "docker 异常" he@jayce.icu 2&gt;&gt; /dev/nullfi</code></pre><p>如果需要自动启动，将  <code>docker start $docker_images_status_exited</code>放入<code>if</code>中即可</p><p>实际运行：</p><p><img src="https://oss.jayce.icu/markdown/202204081344811.png" alt="image-20220408134442666"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
            <tag> Linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KeepAlive详解</title>
      <link href="//post/keepalive.html"/>
      <url>//post/keepalive.html</url>
      
        <content type="html"><![CDATA[<h1 id="KeepAlive详解"><a href="#KeepAlive详解" class="headerlink" title="KeepAlive详解"></a>KeepAlive详解</h1><p>转载地址：<a href="https://www.jianshu.com/p/9fe2c140fa52">KeepAlive详解 - 简书 (jianshu.com)</a> 实际作者不详</p><p>首先，我们要明确我们谈的是<strong>TCP</strong>的 <strong><code>KeepAlive</code></strong> 还是<strong>HTTP</strong>的 <strong><code>Keep-Alive</code><strong>。TCP的KeepAlive和HTTP的Keep-Alive</strong>是完全不同的概念，不能混为一谈</strong>。实际上HTTP的KeepAlive写法是<code>Keep-Alive</code>，跟TCP的<code>KeepAlive</code>写法上也有不同。</p><ul><li>TCP的<strong>keepalive</strong>是侧重在保持客户端和服务端的连接，一方会不定期发送心跳包给另一方，当一方端掉的时候，没有断掉的定时发送几次<strong>心跳包</strong>，如果间隔发送几次，对方都返回的是RST，而不是ACK，那么就释放当前链接。设想一下，如果tcp层没有keepalive的机制，一旦一方断开连接却没有发送FIN给另外一方的话，那么另外一方会一直以为这个连接还是存活的，几天，几月。那么这对服务器资源的影响是很大的。</li><li>HTTP的<strong>keep-alive</strong>一般我们都会带上中间的<strong>横杠</strong>，普通的http连接是客户端连接上服务端，然后结束请求后，由客户端或者服务端进行http连接的关闭。下次再发送请求的时候，客户端再发起一个连接，传送数据，关闭连接。这么个流程反复。但是一旦客户端发送connection:keep-alive头给服务端，且服务端也接受这个keep-alive的话，两边对上暗号，这个连接就可以复用了，一个http处理完之后，另外一个http数据直接从这个连接走了。减少新建和断开TCP连接的消耗。</li></ul><p>二者的作用简单来说：</p><blockquote><p>HTTP协议的Keep-Alive意图在于短时间内连接复用，希望可以短时间内在同一个连接上进行多次请求/响应。</p><p>TCP的KeepAlive机制意图在于保活、心跳，检测连接错误。当一个TCP连接两端长时间没有数据传输时(通常默认配置是2小时)，发送keepalive探针，探测链接是否存活。</p></blockquote><p><strong>总之，记住HTTP的Keep-Alive和TCP的KeepAlive不是一回事。</strong></p><p>tcp的keepalive是在ESTABLISH状态的时候，双方如何检测连接的可用行。而http的keep-alive说的是如何避免进行重复的TCP三次握手和四次挥手的环节。</p><hr><h3 id="TCP的KeepAlive"><a href="#TCP的KeepAlive" class="headerlink" title="TCP的KeepAlive"></a>TCP的KeepAlive</h3><h5 id="1-为什么要有KeepAlive？"><a href="#1-为什么要有KeepAlive？" class="headerlink" title="1.为什么要有KeepAlive？"></a>1.为什么要有KeepAlive？</h5><p>在谈KeepAlive之前，我们先来了解下简单TCP知识(知识很简单，高手直接忽略)。首先要明确的是<strong>在TCP层是没有“请求”一说的</strong>，经常听到在TCP层发送一个请求，这种说法是错误的。</p><p>TCP是一种通信的方式，<strong>“请求”一词是事务上的概念</strong>，HTTP协议是一种事务协议，如果说发送一个HTTP请求，这种说法就没有问题。也经常听到面试官反馈有些面试运维的同学，基本的TCP三次握手的概念不清楚，面试官问TCP是如何建立链接，面试者上来就说，假如我是客户端我发送一个请求给服务端，服务端发送一个请求给我。。。</p><p>这种一听就知道对TCP基本概念不清楚。下面是我通过wireshark抓取的一个TCP建立握手的过程。（命令行基本上用TCPdump,后面我们还会用这张图说明问题）:</p><p><img src="https://oss.jayce.icu/markdown/202204071449977.webp" alt="img"></p><p>TCP抓包</p><p>现在我看只要看前3行，这就是TCP三次握手的完整建立过程，第一个报文SYN从发起方发出，第二个报文SYN,ACK是从被连接方发出，第三个报文ACK确认对方的SYN，ACK已经收到，如下图：</p><p><img src="https://oss.jayce.icu/markdown/202204071449953.webp" alt="img"></p><p>TCP建立连接过程</p><p><strong>但是数据实际上并没有传输</strong>，请求是有数据的，<strong>第四个报文才是数据传输开始的过程</strong>，细心的读者应该能够发现wireshark把第四个报文解析成HTTP协议，HTTP协议的GET方法和URI也解析出来，所以说TCP层是没有请求的概念，HTTP协议是事务性协议才有请求的概念，TCP报文承载HTTP协议的请求(Request)和响应(Response)。</p><p>现在才是开始说明为什么要有KeepAlive。链接建立之后，如果应用程序或者上层协议一直不发送数据，或者隔很长时间才发送一次数据，当链接很久没有数据报文传输时如何去确定对方还在线，到底是掉线了还是确实没有数据传输，链接还需不需要保持，这种情况在TCP协议设计中是需要考虑到的。</p><p>TCP协议通过一种巧妙的方式去解决这个问题，当超过一段时间之后，TCP自动发送一个数据为空的报文给对方，如果对方回应了这个报文，说明对方还在线，链接可以继续保持，如果对方没有报文返回，并且重试了多次之后则认为链接丢失，没有必要保持链接。</p><h5 id="2-怎么开启KeepAlive？"><a href="#2-怎么开启KeepAlive？" class="headerlink" title="2.怎么开启KeepAlive？"></a>2.怎么开启KeepAlive？</h5><p>KeepAlive并不是默认开启的，在Linux系统上没有一个全局的选项去开启TCP的KeepAlive。需要开启KeepAlive的应用必须在TCP的socket中单独开启。Linux Kernel有三个选项影响到KeepAlive的行为：</p><blockquote><ul><li>tcp_keepalive_time 7200// 距离上次传送数据多少时间未收到新报文判断为开始检测，单位秒，默认7200s</li><li>tcp_keepalive_intvl 75// 检测开始每多少时间发送心跳包，单位秒，默认75s</li><li>tcp_keepalive_probes 9// 发送几次心跳包对方未响应则close连接，默认9次</li></ul></blockquote><p>TCP socket也有三个选项和内核对应，通过setsockopt系统调用针对单独的socket进行设置：</p><blockquote><ul><li>TCPKEEPCNT: 覆盖 tcpkeepaliveprobes</li><li>TCPKEEPIDLE: 覆盖 tcpkeepalivetime</li><li>TCPKEEPINTVL: 覆盖 tcpkeepalive_intvl</li></ul></blockquote><p>举个例子，以我的系统默认设置为例，kernel默认设置的tcpkeepalivetime是7200s, 如果我在应用程序中针对socket开启了KeepAlive,然后设置的TCP_KEEPIDLE为60，那么TCP协议栈在发现TCP链接空闲了60s没有数据传输的时候就会发送第一个探测报文。</p><h5 id="3-需要注意，KeepAlive的不足和局限性"><a href="#3-需要注意，KeepAlive的不足和局限性" class="headerlink" title="3. 需要注意，KeepAlive的不足和局限性"></a>3. 需要注意，KeepAlive的不足和局限性</h5><p>其实，tcp自带的keepalive还是有些不足之处的。</p><p><strong>keepalive只能检测连接是否存活，不能检测连接是否可用。</strong>例如，某一方发生了死锁，无法在连接上进行任何读写操作，但是操作系统仍然可以响应网络层keepalive包。</p><p>TCP keepalive 机制依赖于操作系统的实现,灵活性不够，默认关闭，且默认的 keepalive 心跳时间是 两个小时, 时间较长。</p><p>代理(如socks proxy)、或者负载均衡器，会让tcp keep-alive失效</p><p>基于此，我们旺旺需要加上应用层的心跳。这个需要自己实现，这里就不展开了。</p><hr><h3 id="HTTP的Keep-Alive"><a href="#HTTP的Keep-Alive" class="headerlink" title="HTTP的Keep-Alive"></a>HTTP的Keep-Alive</h3><h5 id="1-HTTP为什么需要Keep-Alive？"><a href="#1-HTTP为什么需要Keep-Alive？" class="headerlink" title="1. HTTP为什么需要Keep-Alive？"></a>1. HTTP为什么需要Keep-Alive？</h5><p>通常一个网页可能会有很多组成部分，除了文本内容，还会有诸如：js、css、图片等静态资源，有时还会异步发起AJAX请求。只有所有的资源都加载完毕后，我们看到网页完整的内容。然而，一个网页中，可能引入了几十个js、css文件，上百张图片，如果每请求一个资源，就创建一个连接，然后关闭，代价实在太大了。</p><p>基于此背景，我们希望连接能够在<strong>短时间内</strong>得到复用，在加载同一个网页中的内容时，尽量的复用连接，这就是HTTP协议中keep-alive属性的作用。</p><blockquote><ul><li>HTTP的Keep-Alive是<strong>HTTP1.1</strong>中<strong>默认开启</strong>的功能。通过headers设置”Connection: close “关闭</li><li>在HTTP1.0中是<strong>默认关闭</strong>的。通过headers设置”Connection: Keep-Alive”开启。</li></ul></blockquote><p>对于客户端来说，不论是浏览器，还是手机App，或者我们直接在Java代码中使用HttpUrlConnection，只是负责在请求头中设置Keep-Alive。Keep-Alive属性保持连接的<strong>时间长短是由服务端决定的</strong>，通常配置都是在<strong>几十秒左右。</strong></p><p>TCP连接建立之后，HTTP协议使用TCP传输HTTP协议的请求(Request)和响应(Response)数据，一次完整的HTTP事务如下图：</p><p><img src="https://oss.jayce.icu/markdown/202204071449946.webp" alt="img"></p><p>HTTP请求</p><p>这张图我简化了HTTP(Req)和HTTP(Resp)，实际上的请求和响应需要多个TCP报文。<br>从图中可以发现一个完整的HTTP事务，有链接的建立，请求的发送，响应接收，断开链接这四个过程，早期通过HTTP协议传输的数据以文本为主，一个请求可能就把所有要返回的数据取到，但是，现在要展现一张完整的页面需要很多个请求才能完成，如图片.JS.CSS等，如果每一个HTTP请求都需要新建并断开一个TCP，这个开销是完全没有必要的。</p><p>开启HTTP Keep-Alive之后，能复用已有的TCP链接，当前一个请求已经响应完毕，服务器端没有立即关闭TCP链接，而是等待一段时间接收浏览器端可能发送过来的第二个请求，通常浏览器在第一个请求返回之后会立即发送第二个请求，如果某一时刻只能有一个链接，同一个TCP链接处理的请求越多，开启KeepAlive能节省的TCP建立和关闭的消耗就越多。</p><p>当然通常会启用多个链接去从服务器器上请求资源，但是开启了Keep-Alive之后，仍然能加快资源的加载速度。HTTP/1.1之后默认开启Keep-Alive, 在HTTP的头域中增加Connection选项。当设置为<code>Connection:keep-alive</code>表示开启，设置为<code>Connection:close</code>表示关闭。</p><p>如果tcp keepalive没有开启，那么开启http的keep-Alive是不是也没有用。 因为tcp连接都已经关闭了？</p><p>不是。TCP有一个保活计数器，当该时间段内没收到新数据，将自动断开连接，TCP keepalive就是为了刷新对方的保活计数器的。http的keepalive是为了复用一个tcp，避免多次握手。当保活计数器时间段内有收到数据，tcp就不会断开；如果没有收到数据，tcp断开也是应该的，因为占着资源，不发数据，还不如等你要发数据了重新建立一次连接来的好。</p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql 在ubuntu和centos上的安装</title>
      <link href="//post/mysql-install.html"/>
      <url>//post/mysql-install.html</url>
      
        <content type="html"><![CDATA[<h1 id="mysql-在ubuntu和centos上的安装"><a href="#mysql-在ubuntu和centos上的安装" class="headerlink" title="mysql 在ubuntu和centos上的安装"></a>mysql 在ubuntu和centos上的安装</h1><h2 id="ubuntu"><a href="#ubuntu" class="headerlink" title="ubuntu"></a>ubuntu</h2><p>系统：Ubuntu16.04</p><pre class="line-numbers language-none"><code class="language-none">apt-get updateapt-get install mysql-server</code></pre><p>需要注意的是，在安装mysql 后是不可以使用navicat等远程工具进行连接的</p><p>默认安装后，3306端口只绑定给了localhost，所以外网是无法访问的</p><p>解决方法：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">vim /etc/mysql/mysql.conf.d/mysqld.cnf</code></pre><p>将bind-address   = 127.0.0.1注释掉</p><p><img src="https://oss.jayce.icu/markdown/202203091514554.png" alt="image-20210721175850771"></p><p>重启即可</p><pre class="line-numbers language-none"><code class="language-none">systemctl restart mysql service mysql restart</code></pre><p> 接着授予权限：</p><h2 id="centos"><a href="#centos" class="headerlink" title="centos"></a>centos</h2><p>系统：centos7</p><p>下载mysql5.7的本地仓库文件</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">wget -i -c http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm</code></pre><p>将仓库信息添加至yum</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum -y install mysql57-community-release-el7-10.noarch.rpm</code></pre><p>接着在通过yum进行安装</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum -y install mysql-community-server --nogpgcheck</code></pre><p>此时mysql会取代mariadb</p><p>启动mysql服务</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">systemctl start mysqldsystemctl status mysqld</code></pre><p>此时的登陆密码存放在文件里，查看密码，用该初始化密码登录</p><pre class="line-numbers language-none"><code class="language-none">grep "A temporary password is generated" /var/log/mysqld.log|awk '{print $11}'</code></pre><p><img src="https://oss.jayce.icu/markdown/202203091514491.png" alt="image-20220309150733851"></p><p>使用命令登录数据库后，修改该默认密码，否则无法使用</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">ALTER USER 'root'@'localhost' IDENTIFIED BY '$Password';</code></pre><p>其中，新密码必须使用大写，小写，数字和特殊字符组成</p><p>开启远程登录</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">grant all privileges on *.* to 'root'@'%' identified by 'password' with grant option;flush privileges; </code></pre><p>其中%代表所有ip，password替换为数据库密码。</p><h2 id="离线部署"><a href="#离线部署" class="headerlink" title="离线部署"></a>离线部署</h2><p>使用下载好的压缩包解压安装</p><p>首先新建一个mysql账户</p><h2 id="centos一键部署脚本"><a href="#centos一键部署脚本" class="headerlink" title="centos一键部署脚本"></a>centos一键部署脚本</h2><p><strong><a href="https://github.com/HeJayce/linux-and-shell/blob/main/mysql/mysql_install.sh">Rate limit · GitHub</a>，初来乍到，有错请指教，默认密码为<code>Abc123!@#</code></strong></p>]]></content>
      
      
      <categories>
          
          <category> 部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在服务器部署jupyter notebook，实现服务器环境运算</title>
      <link href="//post/jupyter-notebook.html"/>
      <url>//post/jupyter-notebook.html</url>
      
        <content type="html"><![CDATA[<h1 id="在服务器部署jupyter-notebook，实现服务器环境运算"><a href="#在服务器部署jupyter-notebook，实现服务器环境运算" class="headerlink" title="在服务器部署jupyter notebook，实现服务器环境运算"></a>在服务器部署jupyter notebook，实现服务器环境运算</h1><blockquote><p>大学时期为了借用服务器环境，已踩坑无数，今天突然想起来，部署着玩玩，python初学者也可使用jupyter notebook，ipython对python初学者很友好，也很适合做深度学习，数据分析等</p></blockquote><p>能实现随时随地在浏览器上进行Python处理数据等程序</p><p>效果：</p><p><img src="https://oss.jayce.icu/image-20220413234445593.png" alt="image-20220413234445593"></p><h2 id="简单说下jupyter-notebook"><a href="#简单说下jupyter-notebook" class="headerlink" title="简单说下jupyter notebook"></a>简单说下jupyter notebook</h2><p>Jupyter notebook是一种 Web 应用，能让用户将说明文本、数学方程、代码和可视化内容全部组合到一个易于共享的文档中。与常规的py文件不同的是，Jupyter notebook主要运行的是ipython，ipython是一个python的交互式shell，非常适合进行科学计算和交互可视化。</p><p>看下图就能明白区别</p><p>iPython(Jupyter notebook)</p><p><img src="https://oss.jayce.icu/markdown/202202160100134.png" alt="image-20220216010041321"></p><p>Python：</p><p><img src="https://oss.jayce.icu/image-20220413234657376.png" alt="image-20220413234657376"></p><h2 id="开始部署"><a href="#开始部署" class="headerlink" title="开始部署"></a>开始部署</h2><p>直接使用<code> pip install jupyter</code> 即可安装</p><p>但这里我们还是用anaconda，anaconda虽然很臃肿，但包含了许多的库，可以节省许多精力，<strong>即使不安装anaconda也是可以安装</strong></p><h3 id="anaconda安装"><a href="#anaconda安装" class="headerlink" title="anaconda安装"></a>anaconda安装</h3><p>在<a href="https://www.anaconda.com/">Anaconda官网</a>寻找适合linux的安装脚本，这里直接给出地址<a href="https://repo.anaconda.com/archive/Anaconda3-2021.11-Linux-x86_64.sh">https://repo.anaconda.com/archive/Anaconda3-2021.11-Linux-x86_64.sh</a></p><p>由于软件更新，地址可能出现失效，实际已官网提供为准。</p><p><img src="https://oss.jayce.icu/markdown/202202160142772.png" alt="image-20220216014226572"></p><p>下载好脚本后，用scp<code>或</code>ftp<code>上传至服务器</code>，当然也可直接在服务器<code>wget</code><img src="https://oss.jayce.icu/markdown/202202160141546.png" alt="image-20220216014144845"></p><p>运行安装脚本:</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">bash Anaconda3-2021.11-Linux-x86_64.sh</code></pre><p>这里的文件名以自己下载的为准</p><p>运行脚本后，为了方便基本可以全程回车和yes，但建议还是看每项是否都需要yes，一切根据自身情况判断</p><p>安装好后，需要配置环境变量，修改<code>/etc/profile</code>或者<code>/etc/bashrc</code>的配置信息来设置环境变量</p><p>在<code>/etc/profile</code> 中添加：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">export PATH=$PATH:/root/anaconda3/bin</code></pre><p>这里的路径为你安装anaconda的目录</p><p>保存退出，执行<code>source /etc/profile</code></p><p>输入python3 ，看看环境：</p><p><img src="https://oss.jayce.icu/markdown/202202160147985.png" alt="image-20220216014727419"></p><p>如果是上图这样，则不成功，系统调用了原装的python3.6</p><p>执行python3.9，运行anaconda环境：</p><p><img src="https://oss.jayce.icu/markdown/202202160149595.png" alt="image-20220216014906051"></p><p>多版本python的情况可以利用别名进行区分：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">alias python3=python3.9</code></pre><p><img src="https://oss.jayce.icu/markdown/202202160152179.png" alt="image-20220216015210129"></p><p> 安装好anaconda和python环境后，需要对jupyter进行配置</p><p>进入python，执行以下命令</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from notebook.auth import passwd passwd()</code></pre><p><img src="https://oss.jayce.icu/markdown/202202160948965.png" alt="image-20220216094836772"></p><p>此时提示需要输入密码，设置一个进入jupyter notebook的密码，系统会输出一个sha1加密的字符串，这个要保存下来，后面要用</p><p><img src="https://oss.jayce.icu/markdown/202202160950884.png" alt="image-20220216095052523"></p><p>在终端执行jupyter 配置文件生成命令，如果是root用户执行的，加上<code>加上</code>–allow-config``</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">jupyter notebook --generate-configjupyter notebook --generate-config --allow-config</code></pre><p>如果提示找不到命令，请进入<code>anaconda3/etc/jupyter/</code> 目录下执行</p><p>此时会生成一个配置文件jupyter_notebook_config.py ，接着用编辑器打开（命令执行后有目录位置的提示）</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">vim ~/.jupyter/jupyter_notebook_config.py</code></pre><p>在配置文件中添加以下参数：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 允许访问此服务器的 IP，星号表示任意 IPc.NotebookApp.ip = "*"# 运行时不打开本机浏览器c.NotebookAPp.open_browser = False# 之前生成的密码 hash 字串c.NotebookApp.password = 'sha1:781d82cc6080:e047e581703e4f0c6cd6ec4d037b244315aebe9c'# 使用的端口，记得在安全组中开放c.NotebookApp.port= 8000#指定后续程序的目录，创建好再启动c.NotebookApp.notebook_dir = "/root/jupyter_project"# 禁止使用终端c.NotebookApp.terminals_enabled = True</code></pre><p>其余注释的配置，感兴趣的可以自行查询效果，根据自己意愿进行配置</p><p>保存并退出</p><p>启动jupyter notebook</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">jupyter notebook --allow-root</code></pre><p>其中root用户才需要<code>--allow-root</code></p><p>此时系统会出现运行日志，如果报错可根据日志查询报错原因</p><p>如果成功运行，此时，用ip或域名加上刚才配置文件指定的ip，看看能不能访问到</p><p>如果成功进入，输入刚才你设置的密码即可</p><p>需要进行反向代理的，也可以配置nginx，这里不深入了</p><p>测试jupyter notebook</p><p>右上角new一个python3 ，此时会进入jupyter notebook编辑页面，尝试写一些代码，看看python和各类库是否正常</p><p><img src="https://oss.jayce.icu/markdown/202202161006258.png" alt="image-20220216100627203"></p><p><img src="https://oss.jayce.icu/markdown/202202161021586.png" alt="image-20220216102155441"></p><p>个性化定制：</p><p>css文件地址：</p><pre class="line-numbers language-none"><code class="language-none">/root/anaconda3/lib/python3.9/site-packages/notebook/static/custom</code></pre>]]></content>
      
      
      <categories>
          
          <category> 部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
            <tag> python </tag>
            
            <tag> jupyter notebook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>alias的详解与运维</title>
      <link href="//post/alias.html"/>
      <url>//post/alias.html</url>
      
        <content type="html"><![CDATA[<h1 id="alias的详解"><a href="#alias的详解" class="headerlink" title="alias的详解"></a>alias的详解</h1><p>alias 可以为命令指定别名，所谓别名可以省去一长串命令的麻烦</p><h2 id="查看别名"><a href="#查看别名" class="headerlink" title="查看别名"></a>查看别名</h2><p>直接使用命令<code>alias</code>可以查看所有的别名，如果想看某一命令，在alias后跟命令即可</p><p><img src="https://oss.jayce.icu/markdown/202202141523138.png" alt="image-20220214152355809"></p><h2 id="创建别名"><a href="#创建别名" class="headerlink" title="创建别名"></a>创建别名</h2><p>例如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">alias newcmd='cmd'alias install='sudo apt-getinstall'</code></pre><p>上述方式一旦关闭终端，设置的别名就失效了</p><p>可以将命令放入 <del>/.bashrc 中，当每个进程生成时，都要执行`</del>/.bashrc`中的命令</p><h2 id="删除别名"><a href="#删除别名" class="headerlink" title="删除别名"></a>删除别名</h2><p><code>unalias</code> 命令可以将之前的别名删除</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">unalias vi</code></pre><p>使用<code>-a</code>参数可以清除所有的别名</p><h2 id="不使用别名"><a href="#不使用别名" class="headerlink" title="不使用别名"></a>不使用别名</h2><p>当我们为命令加上日常参数后，但有时需要使用原始的命令时，有三种方法可以调用原始命令</p><ol><li>使用命令的绝对路径</li><li>切换命令所在目录，使用<code>./cmd</code></li><li>在命令前使用反斜线<code>\</code></li></ol><h2 id="别名永久生效"><a href="#别名永久生效" class="headerlink" title="别名永久生效"></a>别名永久生效</h2><p>我们通过 alias 命令设置的别名，仅限于在当前的 Shell 中使用，如果系统重启了，那么新设置的别名就失效了。</p><p>如果想让别名永久有效的话，就需要把所有的别名设置方案加入到（$HOME）目录下的 .alias 文件中（如果系统中没有这个文件，你可以创建一个），然后在 .bashrc 文件中增加这样一段代码：</p><pre class="line-numbers language-none"><code class="language-none"># Aliasesif [ -f ~/.alias ]; then  . ~/.aliasfi</code></pre><p>.alias文件：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim .alias######alias tf='tail -f'  #动态查看文件变化</code></pre><p>执行<code>source ~/.bashrc</code></p><h2 id="安全删除"><a href="#安全删除" class="headerlink" title="安全删除"></a>安全删除</h2><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">alias rm='saferm(){ /bin/cp -a $@ ~/backup;rm $@; };saferm $@'</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> 服务器 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins安装</title>
      <link href="//post/jenkins-install.html"/>
      <url>//post/jenkins-install.html</url>
      
        <content type="html"><![CDATA[<h1 id="Jenkins-安装"><a href="#Jenkins-安装" class="headerlink" title="Jenkins 安装"></a>Jenkins 安装</h1><h2 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h2><h3 id="下载jdk"><a href="#下载jdk" class="headerlink" title="下载jdk"></a>下载jdk</h3><p>进入<a href="https://www.oracle.com/java/technologies/downloads/#java8">JDK下载官网</a> 下载JDK</p><p>这里选择下载131版本，如果版本较新也没问题，<a href="https://www.oracle.com/technetwork/java/javase/downloads/java-archive-javase8-2177648.html">老版本下载链接</a> </p><p>在服务器下创建安装的文件夹，在<code>usr</code>文件夹下创建java文件夹</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mkdir -p /usr/java</code></pre><p>将下载好的JDK解压至该文件夹</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tar -zvxf jdk-8u131-linux-x64.tar.gz -C /usr/java</code></pre><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>与windows类似，Linux下配置环境变量只需修改配置文件即可</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">vim /etc/profile</code></pre><p>在文件下添加：</p><pre class="line-numbers language-none"><code class="language-none">#javaexport JAVA_HOME=/usr/java/jdk1.8.0_131export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</code></pre><p>执行<code>source /etc/profile</code>生效</p><p>执行<code>java -version</code> 如果返回版本号则安装成功</p><h2 id="安装Jenkins"><a href="#安装Jenkins" class="headerlink" title="安装Jenkins"></a>安装Jenkins</h2><h3 id="yum源导入"><a href="#yum源导入" class="headerlink" title="yum源导入"></a>yum源导入</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#添加Yum源wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo</code></pre><p>如果该步骤无法下载，报错ERROR: cannot verify pkg.jenkins.io’s certificate, issued by ‘/C=US/O=Let’s Encrypt/CN=R3’:</p><p>这是因为wget命令下载不安全的https 域名下的内容，此时需要安装ca-certificates</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install -y ca-certificates</code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#导入密钥rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key</code></pre><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum install -y jenkins</code></pre><p>如果缺少daemonize，则同样yum安装daemonize</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>访问IP+8080 端口即可访问Jenkins界面</p><p><img src="https://oss.jayce.icu/markdown/202203081427668.png" alt="image-20220308142711995"></p><p>如果不能访问请检查防火墙，添加8080端口</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">firewall-cmd --add-port=8080/tcp --permanentfirewall-cmd --reload</code></pre><p>第一次打开需要解锁Jenkins，查看web端提示的密码文件</p><p><img src="https://oss.jayce.icu/markdown/202203081429423.png" alt="image-20220308142939118"></p><p>将此行密码复制进去即可</p><p>接着选择安装推荐的插件</p><p><img src="https://oss.jayce.icu/markdown/202203081430531.png" alt="image-20220308143042461"></p><p>等待即可</p><p><img src="https://oss.jayce.icu/markdown/202203081431177.png" alt="image-20220308143106111"></p><p>创建管理员</p><p><img src="https://oss.jayce.icu/markdown/202203081445918.png" alt="image-20220308144503922"></p><p>URL可自愿修改</p><p><img src="https://oss.jayce.icu/markdown/202203081458412.png" alt="image-20220308144542253"></p>]]></content>
      
      
      <categories>
          
          <category> 部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 阿里云 </tag>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在服务器部署Jenkins同步github代码</title>
      <link href="//post/jenkins-github.html"/>
      <url>//post/jenkins-github.html</url>
      
        <content type="html"><![CDATA[<h1 id="在服务器部署Jenkins同步github代码"><a href="#在服务器部署Jenkins同步github代码" class="headerlink" title="在服务器部署Jenkins同步github代码"></a>在服务器部署Jenkins同步github代码</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>使用hexo在github托管个人网站后，如果想要在自己的服务器上部署并且代码与github一致，可以使用Jenkins来同步</p><p>Jenkins可以监控github的动作，设置当代码push后，Jenkins监控到这一动作，自动拉取最新的代码</p><h2 id="Jenkins安装"><a href="#Jenkins安装" class="headerlink" title="Jenkins安装"></a><a href="">Jenkins安装</a></h2><h2 id="获取hook"><a href="#获取hook" class="headerlink" title="获取hook"></a>获取hook</h2><p>在安装Jenkins时，已经默认安装了github的插件，首先需要配置全局的github，在管理Jenkins中点击Configure System，进入设置。这里的入口与其他博客可能会有不同，请根据自己安装的Jenkins版本自行判断</p><p><img src="https://oss.jayce.icu/markdown/202202051315671.png" alt="image-20220205131509975"></p><p>找到github的配置块</p><p><img src="https://oss.jayce.icu/markdown/202202051315820.png" alt="image-20220205131557625"></p><p>Jenkins在关联Github前，需要准备好Hook，这个Hook需要点击高级，找到为 Github 指定另外一个 Hook URL，勾选这个CheckBox（一时想不起来中文叫啥了)，获取到这个URL</p><p><img src="https://oss.jayce.icu/markdown/202202051323334.png" alt="image-20220205132303844"></p><p><img src="https://oss.jayce.icu/markdown/202202051323137.png" alt="image-20220205132229972"></p><h2 id="github添加hook"><a href="#github添加hook" class="headerlink" title="github添加hook"></a>github添加hook</h2><p>到github，选择需要同步的项目，进入设置界面，点击Webhooks</p><p><img src="https://oss.jayce.icu/markdown/202202051326764.png" alt="image-20220205132622973"></p><p>新建一个webhooks（右上角Add Webhooks）</p><p><img src="https://oss.jayce.icu/markdown/202202051328277.png" alt="image-20220205132829053"></p><p>这里的Payload URL填写刚才在Jenkins中的URL<code>http://ip:port/github-webhook/</code></p><p>下面选择第三个</p><p><img src="https://oss.jayce.icu/markdown/202202051329104.png" alt="image-20220205132951899"></p><p>在下面勾选Pushes<img src="https://oss.jayce.icu/markdown/202202051330792.png" alt="image-20220205133026618"></p><p>最后点击添加即可</p><p><img src="https://oss.jayce.icu/markdown/202202051331682.png" alt="image-20220205133125556"></p><h2 id="生成sercret-text"><a href="#生成sercret-text" class="headerlink" title="生成sercret text"></a>生成sercret text</h2><p>添加好后，先别急关掉，此时还需要生成一个sercret text，进入github的设置，进入Developer setting，选择Personal Access Token 点击 Generate new token</p><p><img src="https://oss.jayce.icu/markdown/202202051339773.png" alt="image-20220205133943847"></p><p>选择这两个</p><p><img src="https://oss.jayce.icu/markdown/202202051340362.png" alt="image-20220205134047182"></p><p>生成即可</p><h2 id="Jenkins配置github"><a href="#Jenkins配置github" class="headerlink" title="Jenkins配置github"></a>Jenkins配置github</h2><p>返回Jenkins，这里的名称可以随便写</p><p>API URL保持默认<a href="https://api.github.com就行/">https://api.github.com就行</a></p><p>这里需要添加凭据</p><p><img src="https://oss.jayce.icu/markdown/202202051316492.png" alt="image-20220205131650075"></p><p>点击高亮的Jenkins进入添加凭据界面</p><p><img src="https://oss.jayce.icu/markdown/202202051342576.png" alt="image-20220205134249370"></p><p>类型选择sercret text，把刚才生成的sercret text添加到Secret中，id可不写，描述可简单描述即可</p><p>填完后点击下面添加，此时凭据界面就会有刚才添加的sercret text了</p><p><img src="https://oss.jayce.icu/markdown/202202051345485.png" alt="image-20220205134501227"></p><p>最后保存</p><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>回到主界面，新建一个项目，<img src="https://oss.jayce.icu/markdown/202202051345969.png" alt="image-20220205134552671"></p><p>名称自己填，项目类型选择第一个Freestyle project<img src="https://oss.jayce.icu/markdown/202202051346408.png" alt="image-20220205134639318"></p><p>点击确定添加</p><h2 id="配置github仓库"><a href="#配置github仓库" class="headerlink" title="配置github仓库"></a>配置github仓库</h2><p>进入配置界面，选择Github项目，填写仓库地址</p><p><img src="https://oss.jayce.icu/markdown/202202051347122.png" alt="image-20220205134743946"></p><p>源码管理使用Git</p><p>输入仓库的Git地址，例如<code>git@github.com:HeJayce/HeJayce.github.io.git</code></p><p>此时需要添加git的私钥，如果服务器已经配置好，可以直接在<code>.ssh/</code>文件夹找到，复制私钥，点击添加凭据，与刚才类似，但这里类型需要选择SSH Username with private key，其他可以适当写写，但重要的是在下面把私钥复制进去</p><p><img src="https://oss.jayce.icu/markdown/202202051352246.png" alt="image-20220205135210530"></p><p>分支根据自己情况填写，源码库浏览器选择githubweb，URL填写仓库地址</p><p><img src="https://oss.jayce.icu/markdown/202202051403853.png" alt="image-20220205135326208"></p><p>其他安装下图选择即可</p><p><img src="https://oss.jayce.icu/markdown/202202051354450.png" alt="image-20220205135438447"></p><p>最后点击保存即可，此时返回项目界面，点击立即构建，Jenkins就会把仓库代码clone下来，当出现绿色对勾即表示正常，前面的叉都是踩的坑，搞到4点多，终于搞定了</p><p><img src="https://oss.jayce.icu/markdown/202202051356625.png" alt="image-20220205135614058"></p><p>由于我的项目是静态网页，只需要在Nginx中配置下路径即可</p><pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx">server {        listen       80;        server_name  填你的公网ip;        location / {            root /var/lib/jenkins/workspace/jayce_blog;            index index.html;        }    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> 部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> github </tag>
            
            <tag> 阿里云 </tag>
            
            <tag> hexo </tag>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用grafana可视化仪表监控服务器数据和nginx吞吐</title>
      <link href="//post/prometheus-grafana.html"/>
      <url>//post/prometheus-grafana.html</url>
      
        <content type="html"><![CDATA[<h1 id="使用grafana可视化仪表监控服务器数据和nginx吞吐"><a href="#使用grafana可视化仪表监控服务器数据和nginx吞吐" class="headerlink" title="使用grafana可视化仪表监控服务器数据和nginx吞吐"></a>使用grafana可视化仪表监控服务器数据和nginx吞吐</h1><p>Prometheus 服务端负责数据的收集，然后将数据推送至grafana进行前台展示，而如何用Prometheus 采集到服务器和Nginx的数据呢，这里就需要再引入两个工具，服务器数据采用NodeExporter进行采集，Nginx数据通过nginx-module-vts插件进行采集。</p><p>为了服务器环境的整洁，此次监控都将采用docker容器，docker即简单又不影响服务器环境，越来越受欢迎。</p><p>需要在docker上安装的有<br>prometheus    拉取并存储数据 ，node-exporter 收集内核公开的硬件和操作系统指标 grafana  将取出的数据展示可视化<br>具体流程为 node-exporter对服务器进行取数，nginx-module-vts对nginx进行取数，prometheus进行数据统一管理，由prometheus 推送至grafana进行数据展示<br>效果图：</p><h3 id="监控服务器"><a href="#监控服务器" class="headerlink" title="监控服务器"></a>监控服务器</h3><p><img src="https://oss.jayce.icu/image-20220404145449706.png" alt="image-20220404145449706"></p><h3 id="监控nginx"><a href="#监控nginx" class="headerlink" title="监控nginx"></a>监控nginx</h3><p><img src="https://oss.jayce.icu/image-20220404145734567.png" alt="image-20220404145734567"></p><h2 id="安装prometheus"><a href="#安装prometheus" class="headerlink" title="安装prometheus"></a>安装prometheus</h2><p>直接拉取prometheus的镜像</p><pre class="line-numbers language-none"><code class="language-none">docker pull prom/prometheus</code></pre><p>运行prometheus</p><pre class="line-numbers language-none"><code class="language-none">docker run -d --name prometheus prom/prometheus</code></pre><p>然后我们将prometheus的配置文件复制到本地目录，方便修改</p><pre class="line-numbers language-none"><code class="language-none">docker cp -a prometheus:/etc/prometheus/ $PWD/prometheus</code></pre><p>然后停止prometheus，重新创建并使用配置文件运行</p><pre class="line-numbers language-none"><code class="language-none">docker stop prometheusdocker rm  prometheus</code></pre><pre class="line-numbers language-none"><code class="language-none">docker run -d --name prometheus -p 9090:9090 -v $PWD/prometheus:/etc/prometheus prom/prometheus</code></pre><p>注意9090端口在安全组和防火墙开通</p><p>然后访问<code>ip:9090</code>看看是否成功</p><p><img src="https://oss.jayce.icu/markdown/202204081058933.png" alt="image-20220408105846841"></p><p>这里我用域名代替ip，以实际网络环境为准</p><p>查看docker运行的服务：</p><pre class="line-numbers language-none"><code class="language-none">docker ps -a</code></pre><p>安装node-exporter</p><pre class="line-numbers language-none"><code class="language-none">docker pull prom/node-exporter</code></pre><p> 运行</p><pre class="line-numbers language-none"><code class="language-none">docker run -d --name node-exporter -p 9100:9100 -v "/proc:/host/proc:ro" -v "/sys:/host/sys:ro" -v "/:/rootfs:ro" --net="host" prom/node-exporter</code></pre><p>修改prometheus配置文件，让node-exporter数据连接prometheus，</p><pre class="line-numbers language-none"><code class="language-none">vim prometheus/prometheus.yml</code></pre><pre class="line-numbers language-none"><code class="language-none">scrape_configs:  - job_name: "prometheus"    static_configs:      - targets: ['172.26.134.10:9090']        labels:          instance: prometheus  - job_name: 'centos_1'    static_configs:    - targets: ['172.26.134.10:9100']      labels:         instance: centos_1</code></pre><p>targets：选择填prometheus的ip和端口，建议选择localhost或内网地址。job_name：起个名字</p><p>保存退出，重启prometheus</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">docker restart prometheus</code></pre><p>打开浏览器：</p><p><img src="https://oss.jayce.icu/image-20220413235210346.png" alt="image-20220413235210346"></p><p>安装grafana</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">docker pull grafana/grafana</code></pre><p>创建grafana目录</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">mkdir grafana</code></pre><p>启动镜像</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run -d --name=grafana -p 3000:3000 -v $PWD/grafana:/var/lib/grafana grafana/grafana</code></pre><p>打开浏览器</p><h2 id="监控nginx配置"><a href="#监控nginx配置" class="headerlink" title="监控nginx配置"></a>监控nginx配置</h2><p>监控nginx需要使用nginx-module-vts插件，而nginx-module-vts插件的添加又需要重新编译nginx，此方法适用于编译安装而非yum安装</p><p>安装nginx-module-vts</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git clone git://github.com/vozlt/nginx-module-vts.git</code></pre><p>这里会在当前目录下将nginx-module-vts克隆下来，没有git请自行百度安装</p><p>进入nginx原始的目录，准备编译</p><p>在编译前，添加参数<code>--add-module=/path/to/nginx-module-vts</code></p><pre class="line-numbers language-none"><code class="language-none">--prefix=/usr/local/nginx --with-http_gzip_static_module --with-http_stub_status_module --with-http_ssl_module --with-pcre --with-file-aio --with-http_realip_module --add-module=/usr/local/nginx-module-vts</code></pre><pre class="line-numbers language-none"><code class="language-none">make</code></pre><p>编译完成后，将编译好的nginx可执行文件复制到原来的nginx启动目录sbin下</p><p>执行nginx -V，看看有没有nginx-module-vts参数</p><p><img src="https://oss.jayce.icu/markdown/202204021355092.png" alt="image-20220402135521016"></p><p>此时打开nginx配置文件，添加监控接口</p><p><img src="https://oss.jayce.icu/markdown/202204021357475.png" alt="image-20220402135729259"></p><pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx">location /status {        vhost_traffic_status_display;        vhost_traffic_status_display_format html;}</code></pre><p><img src="https://oss.jayce.icu/markdown/202204021358160.png" alt="image-20220402135813113"></p><p>修改prometheus配置文件，添加nginx模块</p><pre class="line-numbers language-none"><code class="language-none">- job_name: 'nginx'    static_configs:    - targets: ['172.26.134.10:9013']      labels:         instance: nginx</code></pre><p>保存并重启</p><p>此时打开公网/内网地址，<code>/status</code>下即可显示nginx数据了</p><p><img src="https://oss.jayce.icu/markdown/202204021412387.png" alt="image-20220402141230288"></p><p><code>/status/format/prometheus</code> :</p><p><img src="https://oss.jayce.icu/markdown/202204021414243.png" alt="image-20220402141427152"></p><p>用nginx将上面的地址转换为prometheus的地址：</p><pre class="line-numbers language-nginx" data-language="nginx"><code class="language-nginx">server {        listen       9013 ;        server_name  172.26.134.10;location /status {        vhost_traffic_status_display;        vhost_traffic_status_display_format html;        }location /metrics{        proxy_pass  http://172.26.134.10:9013/status/format/prometheus;}}</code></pre><p>prometheus配置文件添加，重启prometheus</p><pre class="line-numbers language-none"><code class="language-none">- job_name: 'nginx'   static_configs:   - targets: ['172.26.134.10:9013']     labels:        instance: nginx</code></pre><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">docker restart prometheus</code></pre><p>此时访问IP:9013/metrics ，就可以变成prometheus需要的类型了</p><p><img src="https://oss.jayce.icu/markdown/202204021417501.png" alt="image-20220402141739403"></p><h2 id="配置grafana"><a href="#配置grafana" class="headerlink" title="配置grafana"></a>配置grafana</h2><p>有了数据源，接下来就是配置可视化仪表了</p><p>打开grafana登录页面，默认用户名密码都是admin</p><p><img src="https://oss.jayce.icu/markdown/202204081036547.png" alt="image-20220408103615852"></p><p>登录后会自动提示修改密码，也可以跳过</p><p><img src="https://oss.jayce.icu/markdown/202204081036130.png" alt="image-20220408103651978"></p><blockquote><p>忘记密码操作：</p><p><code>find / -name "grafana.db"</code></p><p><code>sqlite3  grafana.db</code></p><p><code>.tables</code> **</p><p> <code>select * from user;</code> **</p><p><code>update user set password = '59acf18b94d7eb0694c61e60ce44c110c7a683ac6a8f09580d626f90f4a242000746579358d77dd9e570e83fa24faa88a8a6', salt = 'F3FAxVm33R' where login = 'admin';</code></p><p><code>.exit</code></p><p>重启grafana</p><p>密码和用户名都重置为admin</p></blockquote><p>修改即可</p><h4 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h4><p>进入主界面找到下图所示data sources</p><p><img src="https://oss.jayce.icu/markdown/202204081038259.png" alt="image-20220408103844156"></p><p>点击右边蓝色 add data source</p><p><img src="https://oss.jayce.icu/markdown/202204081039713.png" alt="image-20220408103949639"></p><p>选择第一个Prometheus源</p><p><img src="https://oss.jayce.icu/markdown/202204081040727.png" alt="image-20220408104007625"></p><p>填入<code>ip:9090</code>，其他可以不用管，点击最后的保存并测试</p><p><img src="https://oss.jayce.icu/markdown/202204081044265.png" alt="image-20220408104436874"></p><p>正确即出现下图标识：</p><p><img src="https://oss.jayce.icu/markdown/202204081047438.png" alt="image-20220408104713340"></p><h4 id="配置可视化"><a href="#配置可视化" class="headerlink" title="配置可视化"></a>配置可视化</h4><p>导入一个模板，模板可以在此网站挑选<a href="https://grafana.com/grafana/dashboards/">Dashboards | Grafana Labs</a></p><p><img src="https://oss.jayce.icu/markdown/202204081048748.png" alt="image-20220408104801670"></p><p>选择好后，将模板代号填入即可</p><p><img src="https://oss.jayce.icu/markdown/202204081055144.png" alt="image-20220408105512736"></p><p><img src="https://oss.jayce.icu/markdown/202204081055551.png" alt="image-20220408105531459"></p><p>导入成功后，配置好的模板会自动识别数据源，将数据进行展示，如果个别模块没有数据，可以手动配置数据</p><p><img src="https://oss.jayce.icu/markdown/202204081056466.png" alt="image-20220408105653310"></p><p>可在edit模块，选择数据源以及需要展示的数据</p><p><img src="https://oss.jayce.icu/markdown/202204081057411.png" alt="image-20220408105740337"></p><p>nginx同理，但组件需要手动配置数据</p>]]></content>
      
      
      <categories>
          
          <category> 部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Prometheus </tag>
            
            <tag> grafana </tag>
            
            <tag> Linux </tag>
            
            <tag> 可视化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用typora+阿里云oss打造博客写作平台</title>
      <link href="//post/typora-oss.html"/>
      <url>//post/typora-oss.html</url>
      
        <content type="html"><![CDATA[<h1 id="使用typora-阿里云oss-打造博客写作平台"><a href="#使用typora-阿里云oss-打造博客写作平台" class="headerlink" title="使用typora+阿里云oss 打造博客写作平台"></a>使用typora+阿里云oss 打造博客写作平台</h1><h2 id="背景简介"><a href="#背景简介" class="headerlink" title="背景简介"></a>背景简介</h2><p>我使用typora+markdown作为日常笔记的重要工具，但markdown最大的痛点是图片需要单独存放，并不能像word那样保存为一个文件，而遇到分享文件，或者整片复制的情况时，就会出现不能正常显示图片的问题。</p><h2 id="方案介绍"><a href="#方案介绍" class="headerlink" title="方案介绍"></a>方案介绍</h2><p>利用阿里云oss，将涉及到的图片存放在云端，图片的url将是公网地址，不再局限于本机。使用onedrive可以对md文件进行同步，onedrive支持windows，ios，macos，Android同步，同步速度中规中矩。</p><h2 id="阿里云oss"><a href="#阿里云oss" class="headerlink" title="阿里云oss"></a>阿里云oss</h2><p>对象存储oss是阿里云提供的一种云端存储方案，它与网盘最大的区别是，它可以使用url进行查看，而且操作方便，价格实惠</p><p>阿里云oss价格参考</p><p><img src="https://oss.jayce.icu/markdown/202108191438597.png" alt="image-20210819143824267"></p><p>选择最便宜40G，存放图片完全够用。</p><p>类似的存储在不同平台也有很多，只是名字不一样而已，核心功能都一样</p><p>例如腾讯云cos</p><h2 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h2><h3 id="oss准备"><a href="#oss准备" class="headerlink" title="oss准备"></a>oss准备</h3><ol><li><p>到<a href="https://www.aliyun.com/product/oss/">阿里云oss产品官网</a>购买oss服务，根据自身需求购买相应的内存及性能</p></li><li><p>创建Bucket，Bucket相当于仓库，是你将来要存放数据的地方</p><p><img src="https://oss.jayce.icu/markdown/202108191445966.png" alt="image-20210819144518089"></p></li></ol><p>创建Bucket </p><p><img src="https://oss.jayce.icu/markdown/202202022133051.png" alt="image-20210819144620800"></p><p>我使用的图床软件是PicGo， 下载安装这里不多赘述，现在需要将oss的信息添加到PicGo 中，废话不多，直接上配置，打开配置文件，在阿里云的配置区域里，填写自己所买的accessKeyId和accessKeySecret，以及创建的bucket。</p><p><img src="https://oss.jayce.icu/markdown/202202022133067.png" alt="image-20220202210957291"></p><p>记得在设置下面勾选阿里云oss</p><p><img src="https://oss.jayce.icu/markdown/202202022111401.png" alt="image-20220202211152739"></p><pre class="line-numbers language-none"><code class="language-none">"aliyun": {    "accessKeyId": "*******",    "accessKeySecret": "********",    "area": "oss-cn-hangzhou",    "bucket": "jaycehe",    "customUrl": "",    "options": "",    "path": "markdown/"  },</code></pre><p>其次是<code>typora</code>软件，虽然现在收费了，但支持多平台并且真的好用的编辑软件也找不出来了</p><p>想要配置图床，先在偏好设置-图像</p><p><img src="https://oss.jayce.icu/markdown/202202022104031.png" alt="image-20220202210411391"></p><p>把PicGo的路径添加进去，点击验证图片上传选项验证oss是否能正常上传，一般上传正常就会返回成功值</p><p><img src="https://oss.jayce.icu/markdown/202202022114037.png" alt="image-20220202211414361"></p><p>但一般会大大小小出现一些问题，随后会更新问题概述及解决方法，如果出现上传失败，请先检查oss配置，多半问题都出在PicGo的配置和OSS配置上，结合日志和阿里云给出的报错提示 <a href="https://help.aliyun.com/document_detail/42777.html">OSS权限相关常见错误的排查方法</a> 自己排查不出来也可以联系我。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>如果想用oss代替本地图片，首先正常添加图片至markdown文件后，右键即可弹出上传图片选项，点击即可替换图片的本地路径为oss在线链接</p><p><img src="https://oss.jayce.icu/markdown/202202022122264.png" alt="image-20220202212256962"></p>]]></content>
      
      
      <categories>
          
          <category> 部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阿里云 </tag>
            
            <tag> 博客 </tag>
            
            <tag> Markdown </tag>
            
            <tag> OSS </tag>
            
            <tag> typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里云等国内服务器github加速</title>
      <link href="//post/ecs-github.html"/>
      <url>//post/ecs-github.html</url>
      
        <content type="html"><![CDATA[<h1 id="阿里云等国内服务器github加速"><a href="#阿里云等国内服务器github加速" class="headerlink" title="阿里云等国内服务器github加速"></a>阿里云等国内服务器github加速</h1><p>解决在阿里云等国内的服务器上从github上拉代码，但网络不通的情况。</p><p>准备一个v2ray节点</p><h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><h4 id="安装v2ray"><a href="#安装v2ray" class="headerlink" title="安装v2ray"></a>安装v2ray</h4><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">wget https://raw.githubusercontent.com/v2fly/fhs-install-v2ray/master/install-release.sh  --user-agent="Mozilla/5.0"</code></pre><p>如果下载不下来，请通过ftp等方式上传</p><h4 id="运行下载的脚本"><a href="#运行下载的脚本" class="headerlink" title="运行下载的脚本"></a>运行下载的脚本</h4><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">bash install-release.sh</code></pre><p>这个过程时间会有点长，但实测阿里云网络可以安装</p><h4 id="运行v2ray"><a href="#运行v2ray" class="headerlink" title="运行v2ray"></a>运行v2ray</h4><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">systemctl start v2ray</code></pre><p><img src="https://oss.jayce.icu/markdown/202201292331756.png" alt="image-20220129233139100"></p><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><p>在你的Windows 等v2ray客户端下，将配置文件config.json的内容复制到<code>/usr/local/etc/v2ray/config.json</code>下</p><p>   方法：</p><p>   <img src="https://oss.jayce.icu/markdown/202201292333040.png" alt="image-20220129233337800"></p><h4 id="重启v2ray"><a href="#重启v2ray" class="headerlink" title="重启v2ray"></a>重启v2ray</h4><h4 id="使用下命名可测试节点"><a href="#使用下命名可测试节点" class="headerlink" title="使用下命名可测试节点"></a>使用下命名可测试节点</h4><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">/usr/local/bin/v2ray -test -config /usr/local/etc/v2ray/config.json</code></pre><p><img src="https://oss.jayce.icu/markdown/202201292335792.png" alt="image-20220129233516568"></p><p>检查端口是否通畅</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">lsof -i:10809</code></pre><p><img src="https://oss.jayce.icu/markdown/202201292336185.png" alt="image-20220129233619810"></p><p><code>lsof</code>没有命令的可yum install lsof</p><h4 id="添加github代理"><a href="#添加github代理" class="headerlink" title="添加github代理"></a>添加github代理</h4>   <pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">git config --global http.proxy http://127.0.0.1:10809git config --global https.proxy http://127.0.0.1:10809</code></pre><p>此时再克隆代码速度飞快</p><p><img src="https://oss.jayce.icu/markdown/202201292339343.png" alt="image-20220129233925182"></p>]]></content>
      
      
      <categories>
          
          <category> 部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> 服务器 </tag>
            
            <tag> linux </tag>
            
            <tag> github </tag>
            
            <tag> 阿里云 </tag>
            
            <tag> v2ray </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
